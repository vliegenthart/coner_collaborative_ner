1... Introduction 
ResourceDescriptionFramework(RDF)
Figure1:RDFdataforreviewersmodel 
Here the NULL argument indicates absence of rulebases. @BULLET The fourth argument specifies user-defined namespacealiases(ifany).HeretheNULLargument indicates that no user-defined aliases are used, however default aliases such as rdf: are always available. By processing RDF data using SQL the regulardatabase tables can be queried in a single query along with RDF data. For example, a user can join results of RDF query withatraditionalemployeestablesaytofindtheemailid ofthefacultyreviewers: ProvidingRDFqueryingcapabilityinSQLwouldenable applications to easily process domain-specific semantics storedasRDFdatainarelationaldatabase.Thisbecomes evenmoreimportantespeciallyinthecontextofsemantic web applications, since RDF is an important building blockofthesemanticweb
RelatedWork
For querying RDF data, a number of query languages have been developed. This includes RDQL 
1.2OrganizationofthePaper 
Section 2 describes key concepts of supporting RDF_MATCH based queries. Section 3 discusses the designandimplementationoftheRDF_MATCHfunction on top of Oracle RDBMS. Section 4 discusses an RDBMS table function infrastructure enhancement that can eliminate bulk of the mapping overhead for RDF_MATCH queries. Section 5 describes the performance experiments conducted using RDF data for WordNet and UniProt. Section 6 concludes with a summaryandfuturework. 
2... KeyyConcepts 
Thissectiongivestheterminologyusedintherestofthe paper, outlines the requirements for querying RDF data, anddescribeshowtheSQLbasedRDFqueryingscheme meetstheserequirements. 
2.1Terminology 
RDFcanbeusedtocapturedomainsemantics.Thebasic unit of information is a fact expressed as a <subject, property(predicate),object>triple.Forexample,thefact, 'John′s age is 24', can be represented by <'John', 'age', '24'>triple.Acollectionoftriples,typicallypertainingto adomainorsub-domain,constitutesanRDFmodel. Triples in a model can beclassifiedasschematriples and data triples. Schema triples, specified using RDFS, describe the schema-related information (for example, <'age', 'rdfs:domain', 'Person'>), whereas data triples describetheinstancedata.Notethatatriple'ssubjectand propertyarealwaysURIswhileitsobjectcanbeaURIor literal. An RDF model is also referred to as RDF graph, where each triple forms a <property> edge that connects the<subject>nodetothe<object>node. An RDF data set can optionally include one or more rulebases, each containing a collection of rules. A rule when applied to a model yields additional triples. An RDFmodelaugmentedwitharulebaseisequivalenttothe originalsetoftriplesplusthetriplesinferredbyapplying therulebasetothemodel. 
2.2ASQLbasedRDFQueryingScheme 
AtablefunctionisintroducedtoSQLasdescribedbelow to satisfy most of the requirements described in 
RDF_MATCH 
The following query will return both John and Mary as reviewers. The latter is implicitly inferred by applying rulebaserbtothereviewersmodel. AusercancreaterulebasesandaddrulesbyusingAPIs. Oncetherulebasesarecreatedandpopulated,theycanbe specified in a RDF_MATCH query. Note that the RDFS rulebase (named rdfs) is created by the system and is implicitlyavailableforusers. 
3..DesignandImplementation 
This section describes the design and implementation of the SQL-based RDF Querying Scheme. This scheme is implemented on top of Oracle RDBMS. Although the descriptionhereassumesOracleRDBMS,theschemecan besupportedinanyRDBMSthatsupportstablefunctions, materializedjoinviews,andB-treeindexes. 
3.1RDFDataStorageandMultipleDataType Hanlding 
The RDF data must be stored compactly and the storage format should be suitable for efficient query processing. In our scheme, RDF data is stored (after normalization) in two tables: IdTriples (ModelID, SubjectID, PropertyID, ObjectID, …) and UriMap (UriID, UriValue, …). This normalization is critical because URIs (or literals) are typically repeated. Also, it enables efficient query processing due to the compact size.GivenanRDFtriple,itsthreeURIs(orliterals)are first mapped to corresponding identifiers using table UriMap. If no mapping is found for a URI (or literal), a new unique UriID is generated and the new mapping is inserted into the UriMap table. A tuple comprising the ModelID (for the RDF model) and the three UriIDs is thenstoredintotheIdTriplestable. Auserviewiscreatedontheunderlyingtablesholding RDF data, which presents only selective portions (at modelgranularity)oftheRDFdatatotheusersbasedon their privileges. Also, the RDF_MATCH function is executed with invoker's privileges. Thus, this scheme limits each invoker's access via RDF_MATCH query to onlytheappropriateportionoftheRDFdata. TypedliteralsarestoredintheUriMaptablewiththeir type. To support matching between multiple representationsforthesamevalue,suchastheinteger123 and the float 12.3E+1, each literal is mapped to a canonical literal. Literals that represent the same value willmaptothesamecanonicalliteral,andaliteralmaybe its own canonical literal. The canonicalliteralID(which isusedwhenjoiningontheobjectcolumn)andtheexact literalID(whichisusedwhenreturningtheobjecttothe user)arebothstoredinIdTriples.Forsimplicity,queries inthispaperarewrittenasiftherewasasingleobjectID columninIdTriples. The first literal entered for a value becomes the canonical literal. To support mapping other equi-valued literalstothiscanonicalliteral,thereisaflaginUriMap to indicate that the literal is a canonical literal. Further, the pre-defined datatypes are partitioned into families, where all types in a family are associated with a single value space. For example, float and integer types both belongtothenumericfamily.Foreachtypefamily,there isafunctiontoconverttheUriMaplexicalrepresentations into a canonical form, such as a native database type. A function-based index for this purpose is defined on UriMap,soacanonicalformcanefficientlybemappedto thecorrespondingcanonicalliteralduringquerying. 
3.2RDF_MATCHTableFunction 
The RDF_MATCH functionality is implemented as a SQL table function using Oracle's table function interfaces
RDF_MATCHTablefunction 
SQLQueryinvolvingRDF_MATCHtablefunction 
3.3SpeedingupRDF_MATCHQueries 
The speed up is achieved by creating materialized join views), where m >1. For example, if we have a set of triples, (John, address, addr1), (addr1, zip, 03062), then zip is a nested property of John. @BULLET Create a (subject-property matrix) materialized join view each of whose rows contains values of these propertiesforasubjectinthegroup. Queryperformancecanbeimprovedsignificantlythrough theuseofsuchmaterializedjoinviewsbecauseanumber ofjoinscanbeeliminated.Forexample,Table1showsa sampleRDFdataandTable2showsamatrixmaterialized joinviewcreatedforsubjectswhoareStudentswiththeir direct property age and nested property city (named in the view as studiesAt to denote the city where his/her universityislocated). This subject-property matrix can be exploited by an RDBMS optimizer to process an RDF query using the followingquerypatterntoretrievetheageandstudiesAt infoforeachstudent: This query will normally require a 4-way self-join on the IdTriples table (leaving out the conversion between IDs and URIs, for simplicity). However, by using the matrix in 
'(?r ReviewerOf ?c) (?r Age ?a)' or '(?r ReviewerOf ?c) (?c rdf:type Conference)' 
SincepropertyistypicallyspecifiedasaURIvalue,index key with property as the first column may allow pruning the search space to a single range in the B-tree index. Further, having all the three columns (namely PropertyID, SubjectID, and ObjectID) as part of the key may allow index-onlyaccessprovidedtheadditional storage space required for three column indexes can be accommodated. Based upon these observations, we have usedtwothreecolumnindexeswiththefollowingkeysin allofourperformanceexperimentsdescribedinSection5 : <PropertyID, SubjectID, ObjectID> and <PropertyID, ObjectID, SubjectID>. Use of keyprefix compression in indexes allowed reducing the storagespacerequiredfortheindexes. ThechoiceforindexesmaydependontheactualRDF data and workload characteristics. We need to explore further to see how any algorithm for choosing indexes mayneedtobecustomizedtoexploitconstraintssuchas rowformatsusedforRDFtriplesstorageandtypicalRDF queriesthatinvolvemulti-wayselfjoins. 
4..MinimizinggOverheadsbyyan EnhancementtooRDBMS 
ThissectiondiscussesanenhancementtoOracleRDBMS table function infrastructure that can minimize table functionprocessingoverheads. 
RDFQueryProcessingComponents
The RDF query processing time using RDF_MATCH table function (t total ), without the kernel enhancement discussedinSection4.2,canberepresentedasfollows: t total = t core + t sql2proc +t proc2canonical +t canonical2sql 
Here t core represents thecoreprocessingtime,thatis,the cost of SQL query that performs the self-joins on IdTriples table and any additional joins with UriMap table.Oncetheresultsarecomputed,theyarecopiedinto variables of the table function procedure (t sql2proc ), and subsequently it is converted to canonical format (t proc2canonical ) so it can be returned to via RDBMS table function infrastructure, and finally transformed back (t canonical2sql ) so it can be consumed by the outer SQL query. The component, t total -t core , is dependent on the result computed by table function (note: not on the overall result) and hence it will dominate the query costs when thetablefunctionresultsetsizeislarge.TheExperimentI (described in Section 5.3) demonstrates the overheads incurredforvaryingnumberofresultrows.Toavoidthis overhead an enhancement to RDBMS is implemented as discussedbelow. Note that the subquery in bold font is the SQL fragment that is returned from TableRewriteSQL() for the above RDF_MATCHinvocation.Now,thewholeSQLqueryis optimizedandexecuted.Forexample,thefiltercondition ispushedinsidethesubqueryforfurtheroptimization. The advantage of such a scheme is that it avoids the overhead of copying the results into table function variables, as well as eliminates the table function infrastructure overhead of transforming the result to canonical form and re-transforming it back to present in theappropriatedatatypeformat.However,suchascheme isapplicableonlywhenthetablefunctioncanbedefined declaratively using SQL (as is the case for RDF_MATCH). 
ANewTableFunctionInterface
5..PerformanceStudy 
This section describes the performance experiments conductedusingRDF_MATCHtablefunction. 
5.1ExperimentalSetup 
The experiments are conducted using Oracle10g Release 1(10.1.0.2.0)onaRedHatEnterpriseLinuxAS3system withone3.06GHzPentium4CPUand2048MBofmain memory.Adatabasebuffercacheof256MB,sharedpool of 256 MB, and database block size of 8 KB is used. The timings reported below are the mean result from tenormoretrialswithwarmcaches. 
5.2Dataset 
The experiments I through IV are conducted using an RDF representation of WordNet 
Figure3:WordNetRDFSchema 
The hyponymOf property is used to denote that the subject represents a specialization of the object. For example,skyscraperisahyponymofbuilding. 
Table3.PropertyandResourceStatisticsofWordNet 
The relevant logical statistics for the experimental configuration is shown in 
Experiment II: Varying Number of Triples in the SearchPattern
As the number of triples in the RDF_MATCH search pattern increases, RDF_MATCH performs an increasing numberofself-joinsontheTriplestable.Tocharacterize how the varying number of self-joins impacts performance,queriesareruntofind'hyponymOf'pathsof varying length. For example, the query to findtwo-triple 'hyponymOf'pathsis: Thequeriesarerunwithoutmaterializedviews,andwitha generic SubjectID-ObjectID materialized view, as described in Section 3.3. 
5.7ExperimentV:Large-ScaleRDFData 
This experiment characterizes RDF_MATCH performance for querying large-scale data. UniProt proteinandannotationdatainRDFformat
Table5.RDF_MATCHPerformanceScalability 
(#2)aquerythatselects?n,?cre,and?mod.Eachquery was posed with and without use of the SPMJV. The results in 
6..ConclusionsandFutureWork 
The paper proposed a SQL based scheme for querying RDFdata.Specifically,theRDF_MATCHtablefunction is introduced with the ability to perform pattern-based match against RDF data (graph) that can optionally includetriplesinferredbyapplyingRDFSoruser-defined rules. Users can do further processing (iterate over, constrain using filter conditions, limit the results, etc.) usingstandardSQLconstructs. The RDF_MATCH table function itself is implemented by generating a SQL query against tables holdingRDFdata.Forefficientqueryprocessing,generic and subject-property matrix materialized join views, and indexes (on RDF data and rulebases) are used. Furthermore, a kernel enhancement is implemented that eliminates RDF_MATCH table function run-time processingoverheads. TheexperimentalstudyconductedusingRDFdatafor WordNet and UniProt demonstrates that the SQL based schemeisefficientandscalable. We expect that providing RDF querying capability as part of SQL will enable a database system to support wider range of applications as well as facilitate building semantically rich applications. The RDF querying capability can also be used in conjunction with data mining techniques on RDF data collected from diverse applicationstodiscoverinterestingsemanticrelationships. In future, we plan to consider alternate storage representations for RDF triples. A promising storage representation is partial normalization, where only the namespacesarenormalized.Thatis,URIsarerepresented by the (namespace identifier, URI suffix). Also, we plan to enhanceRDBMSoptimizertoimproveitscapabilities in optimizing the class of self-join queries that typically occurwhilequeryingRDFdata.Theselectionofsuitable join method, join order, and subject-property matrix materializedjoinviewsiscriticalingeneratinganoptimal plan. Allowing users to specify hints to influence the optimizationprocesswillalsobeexplored. 
