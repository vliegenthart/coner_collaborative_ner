Definitions
Object-oriented tcchnologics in use today include object-oriented programming languages (e.g., C++ and Smalltalk), object-oriented database systems, object-oriented user interfaces (e.g., Macintosh and Microsoft window systems, Frame and Interleaf desktop publishing systems), etc. An object-oriented technology is a technology that makes available to the users facilities that are based on " object-oriented concepts " . To define " object-oriented concepts " , we must first understand what an " object " is. 
The term " object " means a combination of " data " and " program " that represent some real-world entity. For example, consider an employee named Tom; Tom is 25 years old, and his salary is $25,000. Then Tom may be represented in a computer program as an object. The " data " part of this Permisrion to copy without fee all or part of thir materio/ ir granted provided that the copier are not made ot distributed JOT direct coynmercial advantage, the VLDB copyright notice and the title of the publication and itr date appear, and notice ir given that copying ia by permiskon of the Very Large Data Bare En- dowment. To copy oiherwiee, or to republish, rcqminr a Jee and/or special pemiwion from the Endowment. Proceedinga of the 19th VLDB Conbrence Dublin, Ireland 1993 object would be (name: Tom, age: 25, salary: $25,000). l'hc " program " part of the object may be a collc4Xion of programs (hire, retrieve the data, change age, change salary, fire). 'I'hc data part consists of data of any type. For the " Tom " object, string is used for the name, intcgcr for age, and monetary for salary; but in general, cvcn any uscr-dcfincd type. such ;LV Employee, may be used. In the " Tom " object, the name, age, and salary arc called attributes of the object. Often, an object is said to " cncapsulatc " data and program. This means that the users cannot SIX the inside of the ohjcct " capsule " . but can use the object by calling the program part of the object. This is not much diffcrcnt from proccdurc UIIS in conventional programming; the users call a prwcthm hy supplying values for input paramctcrs and rcccivc rcsulL\; in output pwamctcfs. 
The term " object-oricntcd " roughly m&s a wu~hiaation of object encapsulation and inhcritancc. 'I'hc l~'rll1 " inhcritancc " is sometimes called " rcusc " . Inhcri~~~ncc III~WU roughly that a new object may bc crcalctl by cxlcndiug an existing object. Now Ict us understand the term " inhcritnncc " more precisely. An object has a data part and a program part. All objects that have the same attributes for the data l~rrt and samcprogrampartarecollcctivclycalIcdaclass(or lyl~).'l'l~c classes arc arranged such that some class may inherit the attributes and program part from some other classes. Tom, Dick, and Harry arc each an Employee objrct. 'I'hc data m of each of thcsc objects consists of the atlributcs Name, Age. and Salary. Each of thcsc Employee objccls Ilas the .samc program part (hire, rctricvc the dalir, change age, change salary, lirc). Each program in the program part is calleda " mcthod " . The term " class " rcfcrs to the collection 01 all objects that have the same attributes and n~cth~x~s. In our example, the Tom, Dick, and Harry objects belong IO UIC chss Employee, since they all have the s3111c attributes and methods. This class may bc used as the tylx of an attribute 01 any object. At this time, thcrc is only one class in the S~SICIII. namely, the class Employee; and three objects that belong to the class, namely, Tom, Dick, and Harry objects. NOW suppose that a user wishes to crcatc two sales cmployccs, John and Paul. But salts cmployccs have XI additional attribute, namely, Commission. 'I'hc salts employc42cannot belong to thcclass Employee. Howcvcr, the user can crcatc a new class, Salts-Employee, such that all atuibutcs and methods associated with the class Employee. may be reused and the attribulc Commission may bc added IO Sales-Employee. The user does this by declaring the class Sa1es~Employe.e tobca " subclass " of thcclassEml)loycc. '11~ user can now proceed to crc;Ite the two salts c~~~ployccs as objects belonging to the cla~ss SalcsEmploycc. The users can CrCillC rl0W claS~~1IsSIIIN:IiI!~SCso~CxistinlJc~R~S. lngeneral, II cl:rss wuy inkit I'ron~ WN: or mm exisliny bless, and tic inhcritancc slruclurc of classes bccomcs a directed acyclic graph (DAG): but for simplicity, the inheritance structure is called an " inhcritancc hierarchy " or " class hierarchy " . The power of object l ricntcd concepts is delivered when encapsulation and inhcritancc work together. -Since inheritance makes it possible for different classes to share the same set of attributes and methods, the same program can be run against objects that belong to different classes. This is the basis of the object-oriented user interface that desktop publishing systems and windows management systems provide today. The same set of programs (e.g., open, close, drop, create, move, etc.) apply to different types of data (image, text file, audio, directory, etc.). -If the users delinc many classes, and each class has many attributes and methods. the benefit of sharing not only the attributes but also the programs can be dramatic. The atlributcs and programs ncal not be defined and written from scratch. New classes can bc crcatcd by adding attributes and methods to existing classes, rather than by modifying the attributes and methods of existing classes, thereby reducing the opportunity to introduce new errors to existing classes. 
Promises of OODBs
An object-&Wed programming language (OOPL) provides facilities to crcatc classes for organizing objects, to create objects, to structure an inheritance hrerarchy to organize classes so that subclasses may inherit attributes and methods from superclasses, and to call methods to access specific objects. Similarly, an object+riented database system (OODB) should provide facilities to create classes for organizing objects, to crcatc objects, to structure an inhcritancc hierarchy to organize classes so that subclasses may inherit attributes and methods from superclasses, and to call methods to access specific objects. Beyond these, an OCDB, because it isadatabascsystem,mustprovidestandard database facilities found in today's relational database systems (RDBs), including nonprocedural query facility for rctricving objccu, automatic query optimrzation and processing, dynamic schema changes (changing the class definitions and inheritance structure), automatic management of access methods (e.g., B+-tree index, extensible hashing, sorting, etc.) to improve query processing performance, automatic transaction management, concurrency control, rccovcry from system crashes, security and authorization. Programming languages, including OOPLs, are designed with one user and a relatively small database in mind. Database systems are designed with many users and very huge databa.scs in mind; hence performance, security and authorization, concurrency control, dynamic schema changes become important issues. Further, database systems are used to maintain critical data accurately; hence, transaction managcmcnt, concurrency control, and recovery are important facilities. Insofar as a database system is a system software whose functions are called from application programs written in some host programming languages, WC may distinguish two diffcrcnt approaches to designing an OODB. One is to Store and manage objects created by programs written in an OOPL. Some of the current OODBs are designed to store and manage objccls generated in C++ or Smalltalk programs. Of course, an RDB can be used lo slorc and manage such objects. Ilowcver, RDBs do not understand objects, in particular, methods and inheritance. Therefore, what may be called an " object manager*' or an " object-oriented layer " software needs to be written to manage methods and inheritance, and to translate objects to tuples (rows) of a relation (table). But, the object manager and RDB combined are in effect an OODB (with poor performance of course)! Another approach is to make object-oriented facilities available to users of non-OOPLs. The users may create classes, objects, inheritance hierarchy, etc.; and the database system will store and manage those objects and classes. This approach in effect turns non-OOPLs (e.g., C, FORTRAN, COBOL, etc.) into object-oriented languages. In fact, C++ has turned C into an OOPL. and CLOS has added object4ented programming facilities to CommonLISP An OODB designed using this approach can of course be used to store and manage objects created by programs written in an OOPL. Although a translation layer would need to be written to map the OOPL objects lo objects of the database system, the layer should be much less complicated than the object manager layer that an RDB would require. lnviewofthefactthatC++,despiteitsgrowingpopularity, is not the only programming language that database application programmers are using or will ever use, and there is a significant gulf between a programming language and a database system, the second approach is a more practical basis of a database system that will deliver the power of object-oriented concepts to database application programmers. Regardless of the approach, OODBs, if done right, can bring about a quantum jump in the productivity of database application programmers, and even in the performance of the application programs. One source of the technological quantum jump is the reuse of a database design and program that objectariented concepts make possible for the first time in the evolving history of database technologies. Object-oriented concepts are fundamentally designed to reduce the difficulty of developing and evolving complex software systems or designs. Encapsulation and inheritance allow attributes (i.e., database design) and programs to be reused as the basis for building complex databases and programs. This is precisely the goal that has driven the data management technology from file systems to relational database systems during the past three decades. An OODB has the potential to satisfy the objective of reducing the difficulty of designing and evolving very large and complex databases. Another source of the technological jump is the powerful data type facilities implicit in the object-oriented concepts of encapsulation and inheritance. The data type facilities in fact are the keys to eliminating three of the important deficiencies of RDBs. These are summarized below. I will discuss these points in greater detail later. -RDBs force the users to represent hierarchical data (or complex nested data, or compound data) such as bill of materials in terms of tuples in multiple relations. This is awkward to start with. Further, to retrieve data thus spread out in multiple relations, RDBs must resort to joins, a generally expensive operation. The data type of an attribute of an object in OOPLs may be a primitive type or an arbitrary user-defined type (class). The fact that an object may have an attribute whose value may be another object naturally leads to nested object representation, which in turn allows hierarchical data to be naturally (i.e., hierarchically) represented. -RDBs offer a set of primitive, built-in data types for use asdomainsofcolumnsofrelations, butdonotofferany means of adding user-defined data types. The built-in data types are basically all numbers and short symbols. RDBs are not designed to allow new data types to be added, and therefore often require a major surgery to the system architecture and code to add any new data type. Adding a new data type to a database system means allowing its use as the data type of an attribute, that is, storage of data of that type, querying and updating of such data. Object encapsulation in OOPLs does not impose any restriction on the types of data that the data part of an object may hold, that is, the types of data may be primitive types or user-defined types. Further, new data types may be created as new classes, possibly even as subclasses of existing classes, inheriting their attributes and methods. -Object encapsulation is the basis for the storage and management of programs as well as data in the database. RDBs now support " stored procedures " , that is, they allow programs to be written in some procedural language and stored in the database for later loading and execution. However, the stored procedures in RDBs are not encapsulated with data; that is, they are not associated with any relation or any tuple of a relation. Further, since RDBs do not have the inheritance mechanism, the stored procedures cannot automatically be reused. 
Reality of OODBs
There are a number of commercial OODBs. These include Gemstone from Servio Corporation, ONTOS from ONTO& ObjectStore from Object Design, Inc., Objectivity/DB from Objectivity, Inc., Versant from Vcrsant Object Technology, Inc., Matisse from Intellitic International (France), Itasca (commercial version of MCC's ORION prototype) from Itasca Systems, Inc.,02 from 02 Technology (France). These products all support an object-oriented data model. Specifically, they allow the user to create a new class with attributes and methods, have the class inherit attributes and methods from superclasses, create instances of the class each with a unique object identifier, retrieve the instances either individually or collectively, and load and run methods. These products have been in the market since as early as 1987. However, most of them have been in evaluation, and preliminary prototype application development; that is, they have not been seriously used for many missionnitical applications. Further, a fairly large number of copies of the products have been given away for free trial, artificially boosting the totaI count of product installations. The worldwide market size for all of the cutrent OODBs combined is estimated to be $20-30 million -a tiny fraction of the $3 billion worldwide market size for all database products. To be sure, the past several years have been a gestation period for object-oriented technology in general. and object-oriented database technology in particular. Further, the technical market and OOPL market which the current QQDBs have targeted are new markets that have not been previously relied on database systems. However, the lack of maturity of the initial (and to a good extent, the current) OODB offerings has also contributed significantly to their slow acceptance in mission-critical applications. 
Limitations limitations as persistent storage systems
One key objective and therefore, selling point, of IWSI of the current OODBs is the support of a unifi4 programming and database language, that is, one language (eg., C++ or Smalltalk) in which todo both general-purpose programming and databasemanagement. Thisobjectivc was the result ofthc current situation where ap combination of a P lication programs arc written in a genera -purpose programming language (mostly. COBOL, FORTRAN, PL/I. or C), and database management functions are embedded within the application programs in a database language (c.g., the SQL relational database language). A gcncral-purpose programming language and a database language arc very different in synmx and data model (data structures and data types), and the necessity of having to learn and use two very dill&em languages to write database application pro *rams has been frequently regarded as a major nuisance. b incc C++ and Smalltalk aIready include facilities for defining clas.ses and a class hierarchy (i.e., for data definition), in cffcct, these languages are a good basis for a unilied programming and database language. The first step that most of the vendors ol the early OODBs took was to make the classes and instances of the classes persistent, that is, to store them on secondary storage and make them acccssiblc cvcn after the programs which defined and crcatcd them have terminated. Current OODBs that arcdcsigncd to support (XWLs place various restrictions on the dclinition and use of objects. III particular, most systems treat persistent data diffcrcntly from nonpersistent data (e.g., they make it illegal for a pcrsistcnt object to contain the OID of a nonpersistent ObjW). and therefore require the users to explicitly dcclarc whcthcr an object is persistent or not. Further, they cannot make ccrtaiu types of data persistent, and therefore prohibit their USC. 
limitations as database systems 
The second, much more severe, source of immaturity of most of the current OODBs products is the lack of basic features that users of database systems have become accustomed to and therefore have come to expect. The features include a full nonprocedural query language (along with automatic query optimization and processing), views, authorization, dynamic schema changes, and paramclerizcd performance tuning. Besides these basic fcaturcs, RDBs offer support for triggers, mcta data managemcnl, constraints such as UNIQUE and NULL -features that mosl OODBs do not support. -Most of the OODBs suffer from the lack of query facilities; and those few systems that do provide significant query facilities, the query language is not ANSI SQL-compatible. Typically, the query facilities do not include nested subqueries, set queries (union, inlcrscction, difference), aggregation functions and group by, and cvcn joins of multiple classes, etc. -facilities fully supported in RDBs. In other words, these products allow the users tocreale a flexible database schema and populate the database with many instances, but they do not provide a powerful enough means of retrieving objects from the database. -RDBs support views as dynamic windows into the stored database. The view definition includes a query statement IO specify the data that will be fctched to constitute the view. A view is used as a unit of authorization. No OODB today supports views. -RDBs support authorization -that is, they allow the users lo grant and rcvokc privileges to read or change the tuples in the tables or views they created to other users, or to change the definition of the relations they created to other users. Most OODBs do not support authorization. -RDBs allow the users to dynamically change tbe databa.sc schema using the ALTER command, a new column may bc added to a relation, a relation may be dropped, and a column can somctimcs be dropped from a relation. However, most of the current OODBs do not allow dynamic changes to the database schema, such as adding a new attribute or method to a class, adding a new superclass to a class, dropping a superclass from a class, adding a new class, and dropping a class. -RDBs automatically set and release locks in processing query and update statcmcnts the users issue. However, some of the current OODDs rcquirc the users to explicitly set and rclea.se loch. -RDBs allow the installation to tune system performance by providing a large number of paramctcrs that can be set by the system administrator. The parameters include the number of memory buffers, the amount of free spacereservedper data page for future insertions of data, and so forth. Most of the OODBs offer a limited capability for parameter&d performance tuning. Because of the dcficicncics outlined above, most of these products will require majorcnhanccmcnts. It is safe toassume that the vendors of these products will make the required changw to their current software4 rather than rewriting the products from scratch. The extent of the changes that wd.l be required to bring these products to full-fledged database systems that can at lcast match the level of database functionality expected of today's database systems is so great that it is not expected that the enhanced products will attain the robustness and performance required for mission-critical applications within the next three or four years. Upgrading most of the current OODBs to true database systems poses not only major technical difficulties as outlined above, but also a serious philosophical difficult . As we have seen already, most of the curn?nt OODBs are c r oser Lo being mcrcly persistent storage systems for some OOPL than tlatabasc systems. The term OODB was not deliberately dcsigncd to be misleading and confusing, since the OODBs were designed to manage a database of objects generated by programs written in OOPLs. However, the database users have been trained during the past two decades to think of a database system as a software that allows a large database to bc qucricd to retrieve a small portion of it, that doesnotrequire any hint from the user about how to process any given query, that allows a large number of users to simultaneously read and update the same database, that automatically enforces database integrity in the presence of multipleconcurrent users and system failures, that allows the creator of a portion of a database to grant and rcvokc access privileges to his data to other users, that allows the installation to tune the pcrformanceof a database system by adjusting various system parameters, and so forth. For this reason, the term OODB has become a misnomer for most of the current OODBs. Mosl of the current OODI3s have essentially extended the OOPLs with a run-time library of database functions. These functions must be called from the application programs, with appropriate specifications of the input and output parameters. The syntax of thecalling functions is madeconsistent with the application programming language. As the current OODBs arc upgraded to true database systems, a major extension to the current library of database functions will be necessitated to support query facilities. Today's programming languages, including object-oriented languages, simply are not designed with database queries in mind. A database query may return an indeterminate number of records or objects that satisfy user-specified search conditions. Therefore, the application program must be designed to step through the entire set of records or objects that are turned until there is no more left. This is what led to the introduction of the cursor mechanism in database systems. The result of a database query must therefore be assigned to some data structure and accompanying algorithm that can store and step through an indefinite number of objects. Further, there will arise the need to provide facilities to specify nested subqueries, postprocessing on the result of a query (corresponding to GROUP BY, aggregation functions, correlation queries, etc.), and set queries (union, intersection, difference). In the name of a unified programming and database language, presumably, all these facilities will bc made available to the programmers in a syntax that is consistent with the programming languages. In other words, the unified language approach does not eliminate the need for any of the database facilities; rather, it merely makes the facilities available to the users in a different syntax. Further, the syntax, to be consistent with the host programming languages, is at a low, procedural level. A procedural syntax is always more difficult for non-technical users to learn and use. Therefore, it is not clear if ultimately the unified language approach offers any advantages over that of embedding a database language in host programming languages. 
Myths
There are many myths about OODBs. Many of these myths arc totally without merit, and are the result of the unfortunate label " database system " that has been attached to most of the current OODBs that are not full-fledged database systems comparable to the current RDBs. Some of the myths are the result of the evolving nature of the technology. Yet others represent concerns from purists that in my view are not practically useful. OODBs are 10 to 100 times faster than RDBs Vendors of OODBs often make the claim that OODBs are between 10 to 100 times faster than RDBs, and back up the claim with performance numbers. This claim can be misleadin unless it is carefully qualified. OODBs have two sources o f performance gain over RDBs. In an OODB the value of an attribute of an object X whose domain is another object Y is the object identifier (OID) of the object Y. Therefore,ifanapplicationhasalreadyretrievedobjectX,and now would like to retrieve object Y, the database system may retrieve object Y by looking up its OID. 
The relational join is a two relations on the basis o f: cncral mechanism that correlates the values of a corresponding pair of attributes in the relations. Since two classes m an OODB may in general have corresponding pairs of attributes, the relational join is still useful and, therefore, necessary in OODBs. For example, in 
OODBs can support multimedia data 
OODBs are a much more natural basis, than RDBs, for implementing functions necessary for managing multimedia data. Multimedia data is broadly dcfincd as data of arbitrary type (number, short string, Employee, Company, image audio, text, graphics, movie, a document that contains images and text, etc.) and arbitrary size (one byte, 10K bytes, 1 gigabyte, etc.). The reason is that OODBs allow arbitrary data types to be created and used, the first requirements for managing multimedia data. However, object-oriented paradigm (i.c.. encapsulation, inheritance. methods, arbitrary data types -collcctivcly or individually) does not solve the problems of storing, retrieving, and updating very large multimedia objects (c.g., an image.anaudiopassage,a textual documcnt,a movic,ctc.). OODBs must solve exactly the same cnginecring problems that RDBs have had to solve to allow me BLOB (binary large object) as the domain of a column in a relation, including incremental retrieval of a very large object from the database (the page buffer in gcncral cannot hold the cntirc object), incremental update (a small change in an object should not result in a copying of the cntirc object), concurrency control (more than one user should be able to access the same Iargc object simultaneously), and recovery (logging should not lcad to copying of an entire object). 
Fulfilling the Promises of OODlls
Today, both the deficiencies of RDBs and the prom&s of OODBs are fairly well-understood. Howcvcr, OODBs have not had significant impact in the database market. l'wo of the reasons arc that most of the current OODBs lack maturity as database systems (i.e., they lack many of the key dituihasc facilities found in RDBs) and that they arc not sufficiently compatible with RDBs (i.e., they do not support a supersct of ANSI SQL). The emerging industry and market consensus is that object-oriented technology can indeed bring about a quantum jump in database technology, but there arc at least three major conditions that must be met before it can dclivcr on its promises. First, new database systems that incorporate an object-oriented data model must be full-fledged database systems that arc compatible with RDBs (i.c., whose database language must be a supersct of SQL). Second, application dcvclopment tools and database access tools must be provided for such database systems, just as they arc critical for the use of RDBs. The tools include graphical application (form) generator, graphical browser/editor/designer of the database graphical report generator, database administration tool, and possibly others. Third, a migration path (a bridge) is needed to allow co-existence of such systems with currently installed RDBs, so that the installations may USC RDBs and new systems for different purposes and also to gradually migrate from their current products to the new products. In this section, I will provide an outline of how an object-oriented database system may be built that is fully compatible with RDBs. and how a migration path may be provided from RDBs to such a new database system. UniSQL, Inc. has a commercial database system, UniSQL/X, that supports a superset of ANSI SQL with full objcct-oricntcd cxlcnsions. UniSQL, Inc. also olTcrs grdphical database access ux)ls and application generation tool for USC with UniSQWX. Further, UniSQL, Inc. offers a commercial fctlcratul (multi) database system, UniSQL/M, that allows co cxistcnccof UniSQL/X with RDBs, whilegivingthcusers a singl&-<latahase illusion. I will use UniSQW and UniSQLJM to illustrate key concepts in this section. Unilication of the relational and objeet+ricnted tcchnologics is most dcfinitcly the underpinning for post-rckuional database technology. ORACLE Corporation rcccntly announced plans to develop an object-otiented cxtcnsion to SQL. The ANSI SQL3 standards committee is currently designing object-oriented extensions to SQL2. The oh.jcctivc of SQL3 is exactly the same as that guided the devclopmcnt of the UniSQL/X databaw language. SQL3 is about 3-4 years away. Further, HP's OpenODB supports a databatsc programming language called OSQL that is ba.sed on a combination of SQL and functional data model (rather than relational data modcl).Therc is also a proposal and initial implcmcntation from Texas Instruments for a database programming language called ZQL
Unifying RDBs and OODBs Unification Architectures
Broadly, there arc three possible approaches to bringing togcthcr OODBs and RDBs: gateway, 00-layer on RDB cnginc, and a single cnginc. In the gateway approach, an (X)DB request is simply translated and routed toasingleRDB for processing, and the result rctumed from tbe RDB is sent to the user issuing the original request. The gateway appears IO the RDB as an ordinary user of the RDB. The current irnplcmcntations of gateways impose various restrictions on the (X)I)B rcqucsu; they citbcr accept only read requests, only one request (rather than a sequence of requests as a single 
Lriln.~clion), or only simple requests (i.e., not alI types of qucricscomparablc to those RDBsarccapableofprocessing). Although tbc gateway approach makes it possible for an application program to USC data retrieved from both an OODB and an RDB, it is not a serious altcmative for unifying r&.ional and object--orient4 technologies. Its performance is unacccptablc bccausc of the cost of translating requests and rctumcd data, and the communication overhead with the RDR. Further, its usability is unacceptable because the application programmers or users have to be aware of tbc cxistcncc of two dilfcrcnt databa.ses. In tbc (Xl-layer approach (cxemplilied by HP's OpcnODB), the user interacts with the system usinganOODB database language (in the cast of OpenODB, an ObjectSQL). and the 00 layer performs all translations of the objcct-oricntcd aspects of the database language to their rclationnl equivalents for interdction wilh the underlying RDB. The translation ovcrhcad can be significant, and Lhis architccturc inhcrcntly compromises performance. For cxarnplc, the 00 layer would map objects to tuplcs of relations. and gencralc the OIDs of objects and pass them to the RDB as an attribute of the tuple, using the interface the RDB makes available; it would also map an OID found in an object to its corresponding object stored in the RDB, again using the RDB interface; and so forth. An RDB consists of two layers: data manager layer and storage manager layer. The data manager layer processes the SQL statements, and the storage manager layer maps the data to the database. The 00 layer may be interfaced with either the data manager layer (i.e., talk to the RDB via SQL statements) or the storage manager layer (i.e., talk to the RDB via low-level procedure calls). The data manager interface is much slower than the storage level interface. (OpenODB uses the data manager interface between its 00 layer and the underlying RDB). Since this approach assumes that the underlying RDB will not bc modified to better accommodate the needs of the 00 layer, it can incur serious performance and operational problems when sophisticated database facilities need to be supported. For example, if a large number of classes in a class hierarchy must be locked (e.g., to support dynamic schema changes), the 00 layer must either acquire locks one at a time (incurring a performance penalty and risking deadlocks), since an RDB has no provision for locking a class hierarchy atomically (roughly, in one command); or lock the entire database with one call to the underlying RDB (potentially preventing any other user from accessing any part of the database). Ncitbcr option is desirable. Further. if the 00 layer is to support updates toobjects in memory and automatically flush updated objects to the database when the application's transaction commits (finishes), the individual objects must be inserted back into the database one at a time, using the RDB interface. The rdtionale for the 00-layer approach is to be able to port the 00 layer on top of a variety of existing RDBs; this flexibility is obtained at the expense of performance. The 00-layer approach is the basis of a database system that makes a variety of databases appear to be a single database to application programs. Such a database system is known as a " multidatabase system " . The 00-layer approach can be used as a basis of a multidatabase system that makes it possible for application programs to work with data retrieved from OODBs and RDBs. 1 note that OpenODB currently is not a multidatabase system. Its 00 layer can connect to only one RDB. I will discuss multidatabase systems in greater detail later. The unified approach melds the 00 layer and the RDB into a single layer, while making all necessary changes in both the storage manager layer and the data manager layer of the RDB. The database system must fully support al1 the facilities the database language allows, including dynamic schema changes, automatic query optimization, automatic query processing, access methods (including B+-tree index, extensible hashing, external sorting), concurrency control, recovery from both soft and hard crashes, transaction management, and granting and revoking of authorizations. The richness of the unified data model added to implementation difficulties. Unifying the Data Models A relational database consists of a set of relations (tables), and a relation in turn consists of rows (tuples) and columns. A row/column entry in a relation may have a single value, and the value may belong to a set of system4efined data types (e.g., integer, suing, float, date, time, money). The user may impose further restrictions, called integrity constraints, on these values (e.g., the integer value of an employee age may be restricted to between 18 and 65). The user may then issue a nonprocedural query against a relation to retrieve only those tuples of the relation the values of whose columns satisfy user-specifiedconditions. Further, the user may correlate two or more relations by issuing a query that joins the relations on the basis of a comparison of the values in user-specified columns of the relations. UniSQLJXgeneralizesandextendsthissimpledatamodel in three ways, each reflecting a key object-oriented concept. A basic tenet of an object-oriented system or programming language is that the value of an object is also an object. The first UniSQL/X extension reflects this by allowing the value of a column of a relation to be a tuple of any arbitrary user-defined relation, rather than just an element of a system-defined data type (number, string, etc.). This means that the user may specify an arbitrary user-defined relation as the domain of a column of a relation. The first CREATE TABLE statement in 
The second UniSQIJX extension is the object-oricntcd concept of encapsulation, that is, combining of data and program (proccdurc) to operate on the data. This is incorporated by allowing the users to attach procedures to a relation and have the procedures opcratcon the column values in each tuplc. The third CREATE TABLE statcmcnt in 
Support for Object Navigation 
Like some OODBs that are designed to make OOPL objects persistent, UniSQL/X provides workspace management facilities to automatically manage a large number of objects in memory (called a workspace or an object buffer pool). In particular, UniSQUx automatically converts the storage format of objects between the database format and the memory format, automatically converts the OIDs stored in objects to memory pointers when objects are loaded from the database into memory, and automatically flushes (writes) objects updated in memory to the database when a the transaction that updated them finish. These workspace management facilities in UniSQL/X make it possible for database application programs to navigate memory-resident objects via memory-pointer chasing, and to propagate changes to individual objects collectively to the database. RDB applications must resort to explicit queries that either join two relations or at least search a single relation to emulate the simple navigation from one object to another related object. Further, RDB applications must also propagate updated tuples one at a time to the database, via the RDB interface (either the data manager level or storage manager level). When a transaction finishes, UniSQL/X automatically se& all objects created or updated by the transaction LO the database to make them persistent. UniSQL/X application programs do not need to do anything to propagate the changes to the database. I note that, unlike most OODBs that also provide workspace management facilities, UniSQL/X supports full query facilities and full dynamic schema evolution. Since at any point in time, an object may exist both in the database and in the workspace, and the " copy " in the workspace may have been updated, a query must be evaluated against the " copies " in the workspace for those objects that have been loaded into the workspace, and against the database objects for those objects that have not been loaded into the workspace. Further, if the user makes a schema change (c.g., drop an attribute 01 a class, or add an attribute to a class), the " topics " of objecti in the workspace become invalid. UniSQL/X takes full account of these considerations in its support of automatic query processing and dynamic schema evolution. Further, workspace managcmcnt facilities ~ccs.senti;~I for making objects persistent and for supporting the performance requirements in object navigation for application programs written in OOPLs. Although UniSQlJX is not wedded to any particular OOPL, the sophisticated workspace managcmcnt facilities provided in UniSQL/X mean that a rather simple translation layer may be implemented on top of UniSQL/X to support any particular OOPL (c.g.. C++ or Smalltalk). 
Interoperating with RDBs
The gateway approach that I discussed as an (unsatisfactory) altemativc for unifying an OODB with RDBs serves one useful purpose. Jt allows an OODB and RDBs to coexist, and can potentially make it possible for one application program to work with data reuievcd from both an OODB and one or more RDBs. As 1 rcmarkcd already, however, the current OODB-RDB galcways typically pass requcststoonlyoneRDB(c.g.,toSybaseortoORACLE),nnd do not treat the separate requests 10 an OODB and to RDB as a single transaction (i.e., collection 0r requests that is trcalcd as a single unit). A multidatabase system (MDBS) is logically a full generalization of a gateway. An MDBS is actually a database system that controls multiple gateways. It does not have iLs own database: it merely manages rcmolc databases through the gateways, one galeway for each remote database. An MDBS presents the multiple remote databases as a single " virtual " database to iti users. Since an MDBS does not have its own " real " database, certain database Facilities, such as those for managing access methods (creatin Bt-tree index, cxtcndible hash table. etc.) an d and dropping performance tuning, bccomc mcaninglcss. parameterizd 
However, an MDBS is a nearly Full-fledged database system. An MDBS must provide data definition facilities so that the virtual database may bc dcfincd on the basis of the rcmotedatabase.s.ThcdatadcFinition facilitiesnccdtoincludc means to harmonize (homogenize) the different rcprcscntations of the semantically equivalent data in different remote databases. An MDBS user may query the definition of the virtual database, query and update the virtual database (requiring query optimization and query processing mechanisms). Multiple MDBS users may simultaneously query, update, and even populate the " virtual " database (requiring concurrency control mechanisms); the users may submit a collection of queries and updates as a single transaction against the virtual database (requiring transaction m,anagcment mechanisms); the users would grant and revoke authorizations on parts of the database to other users (requiring authorization mechanisms). To translate MDBS qucrics and updates to equivalent qucrics and updates that can be proccsscd by remote database systems, an MDBS requires gateways For remote database systems. The gateways in an MDBS are often called 'drivers " and rcmotc database systems are called " local " database systems, and the single virtual database that an MDBS prcscnts to its users is called a " global " database. Further, an MDBS is said to " integrate " multiple local databases into a single global database. UniSQL/M is a multidatabase system From UniSQL, Inc. that integrates multiple UniSQI.,/X databases and multiple relational databases. UniSQL/M is UniSQL/X augmented to access external relational databases and UniSQL/X databases; as such, it is a full-fledged database system and UniSQWM users can query and update the global database in the SQL,iX database language. UniSQI&l maintains the global database as a collection of views dcfincdover relations in local RDBs and classes in local UniSQL/X databases. IJniSQlJM also maintains a directory of the local database relations and classes, their attributes and data types, and methods, that have been intcgratcd into the global database. Using the information in the directory, UniSQL/M translates the queries and updates to cquivalcnt queries and updates For processing by local database systems that manage the data that the queries and updates need to access. The local database drivers pass the translated queries and updates to local database systems, and pass the results to UniSQuM for format translation, merging, and any necessary postprocessing (e.g., sorting, grouping, and joining). Further, UniSQL.IM supports " distributed transaction management " over local databases, which means that all updates issued within one UniSQL/M transaction, even when they rcsuit in updates to multiple local databases, arc simultaneously committed or aborted. RDB vendors today offer gateways of different lcvcls of sophistication. Some gateways allows SQL queries to bc passed to a hierarchical database system (namely. IMS) or file systems such as DEC's RMS. Some gateway is currently being upgraded to accept both queries and updates, and even support distributed transaction management over local databases. However, none of these gateways are designed to pass SQL queries to OODBs; there has been little need to develop such gateways. UniSQL&4 differs From the gateways currently offered by RDB vendors and OODB vendors in three major ways. -UniSQL/M is a full-Fledged database system, rather than a mere gateway, supporting queries, updates, authorization, and transaction management over the global database (the specifications of views defined over local database tables and classes, and directory of information about local database tables and classes). Most current gateways do not accept updates. -UniSQL/M connects to and coordinates queries and updates to multiple local databases For a single UniSQL/M transaction; in particular, it supports distributed transaction management over local databases. Most current gateways pass requests to only one local database, or do not allow simultaneous updates to multiple local databases within a single transaction, when they do, support multiple local databases. There is one more powerful advantage that UniSQL/M offers over any of the current gateways. UniSQL/M extends, although not fully (due to theoretical limitations), local RDBs to UniSQL/X; that is, UniSQL/Mconverts the tuples retrieved From relational local databases into objects by augmenting them with object identifiers and allowing the users to attach methods to them. In this way, UniSQuM makes key object-oriented Facilities provided in UniSQUX indirectly available to local RDBs; in particular, SQL/X path queries, mctbods, and workspace management for objects in UniSQI&vl memory. UniSQL/M may be used in at least three different contexts. First, it maybe used to allow co-existence of UniSQL/X with RDBs. Second, it may be used to turn a collection of RDBs (or a collection of UniSQL/X's) into a distributed database system. Third, when interfaced to a single RDB, it acts as the object management layer for the RDB engine, turning the RDB into UniSQL/X. 
