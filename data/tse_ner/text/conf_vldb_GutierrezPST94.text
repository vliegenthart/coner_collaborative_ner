Introduction
The efficient manipulation of graphs becomes an important challenge for advanced database systems addressing technical applications. Geographical information systems, routing systems, military systems 1 This work is partially funded by the Esprit project IMPRESS 
no 6355 
Permission to copy wthout fee all or part of this material is granted provided that the copies are not maa% or distributed for direct commercial advantage, the VLBD copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Very Large Data Base Endowment. To copy otherwise, or to republish, requires a fee and/or special permission from the Enaknvment. Proceedings of the 20th VLDB 
Application Sample
The database graph view model aims at supporting the requirements of technical applications managing data organized as graphs. Throughout this paper, we use a routing system application to illustrate these requirements and to motivate the solutions we propose. This routing system uses the database presented in 
2.2 Graph View Formal Definition We can identify two main elements that participate in the scenario presented above. First, a set of objects which compose the database defined using a particular data model and second, a set of underlying graphs defined over this database. We fmt give a formal definition of a graph view to fix a non ambiguous semantics for the underlying graphs that can be represented. Conceptually, let Sz be the set of objects of the database. Let S = [Cl, C2, . . . . Cn) be the database scheme. Each Ci is a collection of objects composed of attributes of the form Aj : tj where Aj is the attribute name and tj is the corresponding attribute domain or type. Let D be the universal domain defined as the union of all attribute domain values of the database. A dufubuse graph view of R is a labelled multigraph G = (N, E, LN. LE. Incidence, LabelNode, LabelEdge) where, l N is the set of nodes (node identifiers) of the database graph view taken from n. l E is the set of edges (edge identifiers) of the database graph view taken from fX l LN is a set of node labels taken from D. l LE is a set of edge labels taken from D. l Incidence is a function from E into N x N. l LabelNode is a function from N into LN. l LabelEdge is a function from E into LE. According to this definition, a graph view consists of a set of nodes and a set of edges with associated labels. The nodes and edges are derived from objects of R. Each node and edge must be uniquely identified within a graph view. This does not preclude a single node or edge to be derived from several objects of a or a single object of 62 to participate in the definition of several nodes or edges of the same or different graph view(s). The relations between edges and nodes are given by the Incidence function which allows in particular to define the neighbours of a node. Considering edges and their labels apart allows to have multiple edges with the same valuation between a given pair of nodes. Either directed or undirected underlying graphs can be defined depending on whether or not the Incidence function distinguishes between (n, m) and (m. n) (where n, m E N). The scheme of a database graph view is a tuple of the form (NodeIdType. EdgeIdType, NodeLabelType, EdgeLabelType) where, l NodeIdType is the type of the node identifiers in N. l EdgeIdType is the type of the edge identifiers in E. l 
NodeLabelType is the type of the LN's labels. It has the form (Al : tl, A2 : t2. . . . . Ap : tp). 
Graph View Derivation
Complex graph views can be built by a recursive application of unary and/or binary operators on already defined graph views. Unary operators allow to select a subset of nodes and edges in a graph view and to project the labels of these nodes and edges on relevant values. Binary operators allow the construction of a graph view resulting from the union, the intersection or the difference of two graph views. The derivation operators separate the structural treatment from the label treatment of the operand graph views. The structural part of the graph is given by N, E and the Incidence function, while the label part is given by LN, LE, LabelNode and LabelEdge. Separating the structural part of the graph from its label part allow to compose graphs that can have different NodeLabelType and EdgeLabelType. Note that the binary operators are properly defined only for operand graph views having the same type for their structural part (i.e. same NodeIdType and same EdgeIdType). To illustrate the semantics of each derivation operator, we will use comparable graph views, namely CityRoad and CityTrain, having the following schemes: 
CityRoad (CityName, CityName x CityName, City. (roadtype:RoadType, 1ength:Length)) CityTrain (CityName, CityName x CityName, City, 0) In the following, we define the semantics of the derivation operators in terms of the usual notions in the set theory. Ni, Ei, LNi, LEi, Incidencei, LabelNodei and LabelEdgei denote the elements of a graph view instance Gi. In the figures, nl. n2, . . . . nu denote node identifiers (N elements) while el, e2, . . . . q denote edge identifiers (E elements). 
Union 
The union operation is denoted by y. The union of two graph views consists of the union of the nodes and edges of the graph operands and of the aggregation of their labels. For example, we can derive the complete transportation network between cities by performing the union of the CityRoad and CityTrain graphs. The following example shows the structural result of the union of two graphs. For clarity, labels are not considered in the example but can be easily deduced from the definition. G (NodeIdTypeI , EdgeIdTypel , (NodeLabelTypel u(null))x(NodeLabelType2u( null)), (EdgeLabelTypel u (null)) x(EdgeLabelType2u (null))) l N=NluN2 l E=EluE2 l LN = (.LNI u (null)) x (LN2 u (null)) l LE = (LE1 u (null)) x (LE2 u (null)) This definition leads to two remarks. First, the incidence functions of Gl and G2 generally &liver the same result when applied to the same edge. In particular cases. this result may be different due to an ambiguous identification of edges (see Section 2.5 for a detailed example). In such a case, the definition presented above chooses the incidence function of Gl. Other possible choices could be to select the incidence function of G2 or to discard the corresponding edge. Second, the labels of the nodes and edges resulting from the union are built by aggregating the labels issued from the two operand graphs into a tuple of the form (labell, label2). This could be meaningless when the two operand graphs have the same NodeLabelType and EdgeLabelType. For conciseness, we do not introduce an extra definition to handle this case. This second remark applies as well to all the binary derivation operators. 
Intersection 
The intersection operation is denoted by n. The intersection of two graph views basically consists of the intersection of the nodes and edges of the graph operands and of the aggregation of their labels. For example, we can derive the graph of cities connected both by train and by roads by doing the intersection between the CityRoad and CityTrain graphs. The following example shows the structural result of the intersection of &vo graphs. ) Note that the E set of the graph view result is not merely the intersection of the edges of the graph view operands. Otherwise, an inconsistent graph may be produced if there is an edge in both graphs for which the respective incidence functions give a different result. An edge with extremity nodes that do not belong to N could be generated (see Section 2.5 for an example). Node Difference The node difference operation is denoted by -Node. The node difference between two graph views Gl and G2 yields a subgraph of Gl containing only the nodes of Gl which do not belong to G2 and the edges connecting these nodes. The node difference between the CityRoad and the CityTrain graphs builds the graph of cities which are only connected by roads (and that could claim for a connection to the railway network). The following example shows the structural result of the node difference of two graphs. Edge Difference The edge difference OpemiOn iS denoted by -Edge' The edge difference between two graph views Gl and G2 yields a partial graph of G, containing the edges which do not belong to G2. The edge difference between the CityRoad graph and the graph of blocked roads (i.e. a temporary graph determined by an helicopter pilot) delivers the graph of available roads. The following example shows the structural result of the edge difference of two graphs. G = G1 -Edge G2 is defined by: 
G (NodeIdTypel, EdgeIdTypel, NodeLabelTypel , EdgeLabelTypel) l N=N 1 l E =El-E2 l LN =LN1 l LE=LEI l Incidence (e E E) = IncidenceI (e) l LabelNode (n E N) = LabelNode (n) l LabelEdge (e E E) = LabelEdgel (e) 
Selection 
The selection operation is denoted by PQNode, QEdge. The selection applied to a graph view yields a graph whose nodes and edges satisfy respectively the predicates QNode and QEdge. The attributes that appear in QNode (resp. QEdge) must be attributes of NodeLabelTypel (resp. EdgeLabelTypel). One of these two predicates can be omitted if the selection is applied only to nodes or to edges. These predicates can be expressed by SQLlike predicates or by user-defined functions depending on the way the graph view model is integrated in a system. The following example shows how to obtain from the CityRoad graph the subgraph corresponding to the cities whose population is greater than 6OOK that are connected by roads longer than 400 Km. G = %Node, Qmge K+) is &dined by: 
G (NodeIdTypel, EdgeIdTypel, NodeLabelTypel, EdgeLabelTypel) l N = (n E N, / QNode (LabelNode (n))) 
l E = (e E El / QEdge (LabelEdgel (e)) A 3 n, m E N, Incidence (e) = (n, m)) .LN=LN1 l LE=LE1 . Incidence (e E E) = Incidence1 (e) l LabelNode (n E N) = LabelNode* (n) l LabelEdge (e E E) = LabelEdgel (e) 
Projection The projection operation is denoted by &Node, p~gc. The projection of a graph view G, yields a graph containing the nodes and edges of G, whose labels are the projection of the labels of Gl according to PNode and PEdge. One of these two parameters can be omitted if the projection is applied only to nodes or to edges. is blocked and we want to travel by car in the region Rl and by train in the region R2. We can obtain the graph of available railways and roads by the following expression. 
Nodes and Edges Identification
All the binary derivation operations are based on the node and edge identifiers. These identifiers are defined according to the application needs, resulting in more flexibility in defining graphs over existing databases. The examples given below illustrate how the choice of these identifiers impacts the semantics of different graphs defined on the same data : 1. Road = (CityId, RoadSegmentId, -, -). In this case both identifiers are defined by the database object identifiers. Graph view schemes in which EdgeIdType is different from NodeIdType x NodeIdType allow the definition of multigraphs (i.e. graphs having several edges between two nodes). 2. CityRoad = (CityName, CityName x CityName, -, -). This is an usual definition for graphs that are not multigraphs. The identifiers correspond to some attributes of the database. 3. CityTrain = (CityName, CityName x CityName, -, -). In this case, each node (resp. edge) identifier results from the aggregation of a set of objects at the database level. This flexibility requires adding conditions in the definition of the binary derivation operators to deal with graphs where EdgeIdType is not NodeIdType x NodeIdType nor object identifiers. Taking no precaution in such cases may lead to an ambiguous identification of edges in the graph resulting from the derivation. Let us consider the following graph view schemes: G, = (Region, Point x Point, -, -) G, = (Region, Point x Point, -, -) 
Assume that the database represents the situation pictured in 
Gl G2 
Abstraction Levels
Each derivation operator produces a new derived graph view from one or two existing graph view(s). The derivation rules between graph views can themselves be expressed by a graph where the nodes represent graph views or operators and the edges represent derivation links (see 
Traversing the Underlying Graph of a Base Graph View
There are basically two methods to extract a base graph view from a collection of database objects. The first method consists in materializing the underlying graph defined by the base graph view by building dynamically its collection of nodes and its collection of edges prior to the execution of any graph operator. These two collections must conform to a predefined scheme understandable by all graph operators. The second method consists of defining a function, called Succ(), which delivers for an input node of the underlying graph the set of nodes connected to it. The graph operators can then recursively invoke the Succ() function to traverse the underlying graph. To make these two kinds of translations possible, the following functions have to be included by the DBA in the operational definition of each base graph view G: 
BuildNodeSet + ((n, LabelNode (n)) / n E N ) BuildEdgeSet + ((e, n, m, LabelEdge (e)) / n, m E N A e E E A Incidence (e) = (n, m)) Succ (n E N) + ((e, m, LabelNode (m). LabelEdge (e) / e E E A m E N A Incidence (e) = (n, m)) 
As stated in Section 2.3, BuildNodeSet() and BuildEdgeSet() implement all the elements that enter in the, formal definition of a graph view (i.e. N, E. Incidence, LN. LE. LabelNode and LabelEdge). These two functions build a pseudo-relational form of the underlying graph. We selected this representation for two reasons. First, most of the graph operators proposed in the database literature make the assumption that the graphs are stored as relations. Thus, all the principles introduced to speed up the recursive process on such graphs can be exploited in the graph view context. Second, this representation is well adapted to the storage (roadtype : RoadType, distance : Length)) BuildNodeSet is bee 
Traversing the Underlying Graph of a Derived Graph View
The translation of a derived graph view G into a collection of base graph views (Gl, G2, . ..Gn) can be done by deriving the functions BuildNodeSet(), BuildEdgeSet() and Succ() from the corresponding functions defined on the base graph views Gl, G2, . ..Gn. This translation can be automatically done with no intervention from the DBA part. Each derivation rule between graph views comes with a derivation rule for the three aforementioned functions. The table presented in 
3.4 Pipelined vs. Set-Oriented Query Processing Let us now consider the execution of graph operators over database graph views. For the sake of conciseness, we focus on the processing of the generalized transitive closure operator (integrating computations on the nodes and edges labels) considered as a key operator of future database systems. While important research efforts focused on developing new algorithms and new data structures to support it efficiently, less studies addressed query optimization problems. One important contribution in this area IDAJ911 considers the optimization of generalized transitive closure queries of the form: 
Q = Agg (0 (Con (Paths (G)))) * =, Q 
and lI respectively denote the join, semi-join, selection and projection relational operators. 
asrkciated to relational operators 
When , 12 , , . . . . n denote attribute positions and i+j the concatenation of attributes i and j. where G is an input relation materializing a graph. Paths0 enumerates all the paths of G. For each path, Con0 concatenates the labels of the path edges into a unique path label. 00 selects all paths satisfying some predicates applied on the path label's and/or on the origin and destination nodes of paths. Finally, Agg() aggregates the paths having same origin and same destination as well as the labels of these paths. The contribution leads to a precise classification of the selection criteria attached to cr in the query expression. Whenever possible, these selection criteria are applied on G before starting the recursive process or are evaluated as soon as possible during the recursive process to prune unneeded paths. Such optimization rules can be exploited in the database graph view context as well. Let G be a graph view itself resulting from a potentially complex expression involving graph view derivation operators. If we note D(G1, G2. . ..Gn) the derivation expression of G from the base graph views Gl, G2, . . . . Gn, the query to be optimized becomes: Q = Agg (d (Con (Paths (D(G1, G2, . ..Gn)
)
))) 
In the graph view context, either the graph view G is materialized by composing the functions BuildNodeSet() and BuildEdgeSet() of Gl, G2, . ..Gn and the transitive closure is applied on this materialization, or the transitive closure is directly applied on G by using a Succ() function derived from the Succ() functions of Gl, G2, . . .Gn. We will refer to these two strategies respectively as the set-oriented strategy and the pipelined strategy. Indeed, materializing G leads to a set-oriented evaluation of the expression D(G1, G2. . ..Gn) while this expression is evaluated in a pipelined mode for each Succ() invocation performed by the Paths0 operator. Roughly speaking, the best strategy depends on the size of the underlying graphs, the cost of each Succo invocation, the percentage of edges traversed during the recursive process and the presence of indices. Suppose that a user queries the Road graph view to find the shortest path between node A and node B traversing only the main roads. This can be expressed aS: Q = Min(length) oc Add(1engt.h) Paths (
Integrating the Graph View Model in Existing Systems
The graph view model can be tightly integrated in existing database systems. As pictured in 
Extended Query Optlmlxer 
Figure 10: Graph views integration in a DBMS architecture 
The graph view model can also be the basis of a graph operator library dedicated to applications managing graphs defined using a particular data model and stored in any repository (e.g. files). We are defining such a library integrating path traversal algorithms in the IMPRESS project 
Conclusion
The database graph view model addresses three important requirements of technical applications managing large and complex graph structures. First, the model implements an abstraction mechanism which provides the application designer with the ability to define various underlying graphs on top of objects stored in databases or in files. Connections between nodes and edges may be either represented by physical links between objects or dynamically computed at traversal time. This enables to cope with complex graph organizations that cannot easily be mapped on predefined storage structures for graphs. Second, the model comes with a collection of powerful derivation operators. Graphs having different node and edge types can be combined using these operators to derive ad-hoc underlying graphs satisfying specific application requirements. The semantics of these operators integrates both the set of nodes, the set of edges and the labels of the operand graphs. Third, the model supports different execution strategies for graph operators exploiting graph views. The pipelined, set-oriented and hybrid execution strategies may outperform each other depending on the size of the queried graph and on the number of edges visited at traversal time. This opens new perspectives in the optimization of graph queries. Our future work will focus on performance analysis of the proposed operators in the context of the three different technical applications we are working on. Our objective is to define precise rules for a query optimizer to fully exploit the different execution strategies identified in this paper. 
