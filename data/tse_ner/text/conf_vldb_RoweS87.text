Introduction
This paper describes the data model for POSTGRES, a next-generation extensible database management system being developed at the University of California [23: The data model is based on the idea of extending the relational model developed by Codd [51 with general mechanisms that can be used to simulate a variety of semantic data modeling constructs . The mechanisms include: 1) abstract data types (ADT's), 2) data of type procedure, and 3) rules. These mechanisms can be used to support complex objects or to implement a t This research was supported by the National Science Foundation under Grant DCR-8507256 and the Defense Advanced Research Projects Agency (DOD), Arpa Order No. 4871, monitored by Space and Naval Warfare Systems Command under Contract N00039-84-C-0089. 
Pumission lo copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage. the VLDB copyright notice and the tide of Ihe publication and its date appear. and notice is given that copying is by permission of he Very Large Dam Base Endowment. To copy otherwe. or to republish, requires a fee and/or special permission from the Endowment. Proceedings of the 13th VLDB Conference, 
The remainder of the paper describes the POSTGRES data model and is organized as follows . Section 2 presents the data model. Section 3 describes the attribute type system. Section 4 describes how the query language can be extended with user-defined procedures. Section 5 compares the model with other data models and section 6 summarizes the paper. 
Data Model
A database is composed of a collection of relations that contain tuples which represent real-world entities (e.g., documents and people) or relationships (e.g., authorship). A relation has attributes of fixed types that represent properties of the entities and relationships (e.g., the title of a document) and a primary key. Attribute types can be atomic (e.g., integer, Boating point, or boolean) or structured (e.g., array or procedure). The primary key is a sequence of attributes of the relation, when taken together, uniquely identify each tuple. A simple university database will be used to illustrate the model. The following command defines a relation that represents people: create PERSON ( Name = char[251, Birthdate = date, Height = intl, Weight = int4, StreetAddress = char[251, City = charf251, State = Chad211 This command defines a relation and creates a structure for storing the tuples. The definition of a relation may optionally specify a primary key and other relations from which to inherit attributes. A primary key. is a combination of attributes that uniquely identify each tuple. The key is specified with a key-clause as follows: create PERSON ( . . .) key (Name) Tuples must have a value for all key attributes . The specification of a key may optionally include the name of an operator that is to be used when comparing two tuples. For example, suppose a relation had a key whose type was a user-defined ADT. If an attribute of type box was part of the primary key, the comparison operator must be specified since different box operators could be used to distinguish the entries (e.g., area equals or box equality). The following example shows the definition of a relation with a key attribute of type box that uses the area equals operator (AE) to determine key value equality: create PICTURE(Title = charf251, Item = box) key (Item using AE) Data inheritance is specified with an inherits-clause, Suppose, for example, that people in the university database are employees and/or students and that different attributes are to be defined for each category. The relation for each category includes the PER- SON attributes and the attributes that are specific to the category. These relations can be defined by replicating the PERSON attributes in each relation definition or by inheriting them for the definition of PERSON. 
Relation expressions may include other set operators: union (Uj, intersection !fi), and difference ( -1. For example, the following query retrieves the names of people who are students or employees but not student employ- ees: retrieve (S.name) from S in (STUDENT U EMPLOYEE) 
Suppose a tuple does not have an attribute referenced elsewhere in the query. If the reference is in the target-list, the return tuple will not contain the attribute.' If the reference is in ' The application program interface to POSTGRES allows the stream of tuples passed back to the program to have dynamically varying columns and types. the qualification, the clause containing the qualification is " false " . POSTQUEL also provides set comparison operators and a relation-constructor that can be used to specify some difficult queries more easily than in a conventional query language. For example, suppose that students could have several majors. The natural representation for this data is to define a separate relation: create MAJORS(Sname = char[251, Mname = char
where Sname is the student's name and Mnume is the major. With this representation, the following query retrieves the names of students with the same majors as Smith: 
retrieve Note that a tuple-variable defined in the outer query (e.g., Ml in the query above) can be used within a relation-constructor but that a tuplevariable defined in the relation-constructor cannot be used in the outer query. Redefinition of a tuple-variable in a relation constructor creates a distinct variable as in a block-structured programming language (e.g., PASCAL). Relation-valued expressions (including attributes of type procedure described in the next section) can be used any place in a query that a named relation can be 86 . hoceedines of the 13th VLDB Conference. 
The snapshot version can be updated directly by issuing update commands on the version. But, updates to the base relation are not propagated to the version. A merge command is provided to merge changes made to a version back into the base relation. An example of this command is merge YOURPEOPLE into PERSON that will merge the changes made to YOUR- PEOPLE back into PERSON. The merge command uses a semi-automatic procedure to resolve updates to the underlying relation and the version that conflict 
Data Types
POSTGRES provides a collection of atomic and structured types. The predefined atomic types include: int2, int4, float4, float8, bool, char, and date. The standard arithmetic and comparison operators are provided for the numeric and date data types and the standard string and comparison operators for character arrays. Users can extend the system by adding new atomic types using an abstract data type (ADT) definition facility. All atomic data types are defined to the system as ADT's. An ADT is defined by specifying the type name, the length of the internal representation in bytes, procedures for converting from an external to internal representation for a value and from an internal to external representation, and a default value. The command 88  The external representation of a box is a character string that contains two points that represent the upper-left and lower-right corners of the box. With this representation, the constant " 20,50:10,70 " Operators on ADT's are defined by specifying the the number and type of operands, the return type, the precedence and associativity of the operator, and the procedure that implements it. For example, the command define operator " + " (int4, intl) returns int4 is (Proc = Plus, Precedence = 5, Associativity = " left " ) describes a box whose upper-left corner is at (20, 50) and lower-right corner is at (10, 70). Comparison operators can be defined on ADT's that can be used in access methods or optimized in queries. For example, the definition Another example of an ADT definition is the following command that defines an ADT that represents boxes: define operator AE(box, box) returns boo1 is (Proc = BoxAE, Precedence = 3, Associativity = " left " , Sort = BoxArea, Hashes, Restrict = AERSelect, Join = AEJSelect, Negator = BoxAreaNE) defines an operator " area equals " on boxes. In addition to the semantic information about the operator itself, this specification includes information used by POSTGRES to build indexes and to optimize queries using the operator. was executed. The Sort property of the AE operator specifies the procedure to be used to sort the relation if a merge-sort join strategy was selected to implement the query. It also specifies the procedure to use when building an ordered index (e.g., B-Tree) on an attribute of type box. The Hashes property indicates that this operator can be used to build a hash index on a box attribute. Note that either type of index can be used to optimize the query above. The Restrict and Join properties specify the procedure that is to be called by the query optimizer to compute the restrict and join selectivities , respectively, of a clause involving the operator. These selectivity properties specify procedures that will return a floating point Proceedings of the 13th VLDB Conference. Brkhton 1987 value between 0.0 and 1.0 that indicate the attribute selectivity given the operator. Lastly, the Negator property specifies the procedure that is to be used to compare two values when a query predicate requires the operator to be negated as in retrieve (PICTURE.all) where not (PICTURE.Item AE " 50,100:100,50 " ) The define operator command also may specify a procedure that can be used if the query predicate includes an operator that is not commutative. For example, the commutator procedure for " area less than " (ALT) is the procedure that implements " area greater than or equal " (AGE). More details on the use of these properties is given elsewhere 
CharToBox 
..I 
A student's major(s) can then be represented by a procedure in the STUDENT relation that retrieves the appropriate DEPARTMENT tuple(s). The Majors attribute would be declared as follows: create STUDENTC . . . . Majors = postquel, . 
..) 
Data type postquel represents a procedure-type. The value in Majors will be a query that fetches the department relation tuples that represent the student's minors. The following command appends a student to the database who has a double major in mathematics and computer science: append STUDENT( Name = " Smith " , . . . .  A query that references the Majors attribute returns the string that contains the POSTQUEL commands. However, two notations are provided that will execute the query and return the result rather than' the definition. First, nested-dot notation implicitly executes the query as illustrated by retrieve @Name, S.Majors.Name) from S in STUDENT which prints a list of names and majors of students . The result of the query in Majors is implicitly joined with the tuple specified by the rest of the target-list. In other words, if a student has two majors, this query will return two tuples with the Name attribute repeated. The implicit join is performed to guarantee that a relation is returned. 
The second way to execute the query is to use the execute command. For example, the 4uery execute (S.Majors) from S in STUDENT where S.Name = " Smith " returns a relation that contains DEPART- MENT tuples for all of Smith's majors. 
Parameterized procedure-types are used when the query to be stored in an attribute is nearly the same for every tuple. The query parameters can be taken from other attributes in the tuple or they may be explicitly specified. The dollar-sign symbol ( " $ " ) refers to the tuple in which the query is stored (i.e., the current tuple). The parameter for each instance of this type (i.e., a query) is the Name attribute in the tuple in which the instance is stored. This type is then used in the create command as follows create STUDENT(Name = char
Notice that for a particular STUDENT tuple, the expression " $.Name " in the query refers to the name of that student. The symbol Y$ " can be thought of as a tuple-variable bound to the current tuple. Parameterized procedure-types are extremely useful types, but sometimes it is inconvenient to store the parameters explicitly as attributes in the relation. Consequently, a notation is provided that allows the parameters to be stored in the procedure-type value. This mechanism can be used to simulate attribute types that reference tuples in other relations. An actual argument is supplied when a vaJue is assigned to an attribute of type DEPARTMENT. For example, a COURSE relation can be defined that represents information about a specific course including the department that offers it. The create command is: create COURSE(Title = char
..) 
The attribute Dept represents the department that offers the course. The following query adds a course to the database: append COURSE( Title = " Introductory Programming " , Dept = DEPARTMENT(D.oid)) from D in DEPARTMENT where D.Name = " computer science " The procedure DEPARTMENT called in the target-list is implicitly defined by the " define type " command. It constructs a value of the specified type given actual arguments that are type compatible with the formal arguments, in this case an int4. Parameterized procedure-types that represent references to tuples in a specific relation are so commonly used that we plan to provide automatic support for them. First, every relation created will have a type that represents a reference to a tuple implicitly defined similar to the DEPARTMENT type above. And second, it will be possible to assign a tuple-variable directly to a tuple reference attribute. In other words, the assignment to the attribute Dept that is written in the query above as . . . Dept = DEPARTMENT(D.oid) . . . can be written as . . . Dept = D . 
. . 
Parameterized procedure-types can also be used to implement a type that references a tuple in an arbitrary relation. The type definition is: define type tuple(char[l, int4) is retrieve ($l.all) where $l.oid = $2 end 
The first argument is the name of the relation and the second argument is the oid of the desired tuple in the relation. In effect, this type defines a reference to an arbitrary tuple in the database. 
The procedure-type tuple can be used to create a relation that represents people who help with fund raising: create VOLUNTEER(Person = tuple, TimeAvailable = integer, . 
..I 
Because volunteers may be students, employees, or people who are neither students nor employees, the attribute Person must contain a reference to a tuple in an arbitrary relation . The following command appends all students to VOLUNTEER: append VOLUNTEERS Person = tuple(relation(S), Soid)) from S in STUDENT* The predefined function relation returns the name of the relation to which the tuplevariable S is bound. The type tuple will also be special-cased to make it more convenient. Tuple will be a predefined type and it will be possible to assign tuple-variables directly to attributes of the type. Consequently, the assignment to Person written above as . . . Person = tuple(relation(S), S.oid) . . . can be written . . . Person = S . . . We expect that as we get more experience with POSTGRES applications that more types may be special-cased. 
User-Defined Procedures
This section describes language constructs for adding user-defined procedures to POST- QUEL. User-defined procedures are written in a conventional programming language and are used to implement ADT operators or to move a computation from a front-end application process to the back-end DBMS process. Moving a computation to the back-end opens up possibilities for the DBMS to precompute a query that includes the computation. For example, suppose that a front-end application needed to fetch the definition of a form from a database and to construct a mainmemory data structure that the run-time forms system used to display the form on the terminal screen for data entry or display. A conventional relation database design would store the form components (e.g., titles and field definitions for different types of fields such as scalar fields, table fields, and graphics fields) in many different relations. An example database design is: create FORM(FormName, . 
..) 
create FIELDS(FormName, FieldName, Origin, Height, Width, FieldKind, . ..I create SCALARFIELD(FormName, FieldName, DataType, DisplayFormat, . 
..) 
create TABLEFIELD(FormName, FieldName, NumberOfRows, . ..I create TABLECOLUMNS(FormName, FieldName, ColumnName, Height, Width, FieldKind, . 
..) 
 The query that fetches the form from the database must execute at least one query per table and sort through the return tuples to construct the main-memory data structure. This operation must take less than two seconds for an interactive application. Conventional relational DBMS's cannot satisfy this time con- straint. 
Our approach to solving this problem is to move the computation that constructs the main-memory data structure to the database process. Suppose the procedure MakeForm built the data structure given the name of a form. Using the parameterized procedure-type mechanism defined above an attribute can be added to the FORM relation that stores the form representation computed by this procedure . The commands define type formrep is reirieve (rep = MakeForm($.FormName)) end addattribute (FormName, . . . . FormDataStructure = formrep) to FORM define the procedure type and add an attribute to the FORM relation. The advantage of this representation is that POSTGRES can precompute the answer to a procedure-type attribute and store it in the tuple. By precomputing the main-memory data structure representation, the form can be fetched from the database by a single-tuple retrieve: retrieve (x = FORM.FormDataStructure) where FORM.FormName = " foe " The real-time constraint to fetch and display a form can be easily met if all the program must do is a single-tuple retrieve to fetch the data structure and call the library procedure to 92 display it. This example illustrates the advantage of moving a computation (i.e., constructing a main-memory data structure) from the application process to the DBMS process. A procedure is defined to the system by specifying the names and types of the arguments , the return type, the language it is written in, and where the source and object code is stored. For example, the definition define procedure AgeInYears(date) returns int4 is (language = " C " , filename = " AgeInYears " ) defines a procedure AgeZnYears that takes a date value and returns the age of the person. The argument and return types are specified using POSTGRES types. When the procedure is called, it is passed the arguments in the POSTGRES internal representation for the type. We plan to allow procedures to be written in several different languages including C and Lisp which are the two languages being used to implement the system. POSTGRES stores the information about a procedure in the system catalogs and dynamically loads the object code when it is called in a query. The following query uses the AgeZnYears procedure to retrieve the names and ages of all people in the example database: retrieve (P.Name, Age = AgeInYears(P.Birthdate)) from P in PERSON* User-defined procedures can also take tuple-variable arguments. For example, the following command defines a procedure, called Comp, that takes an EMPLOYEE tuple and computes the person's compensation according to some formula that involves several attributes in the tuple (e.g., the employee's status, job title, and salary): the tuple. User-defined procedures can be passed tuples in other relations that inherit the attributes in the relation declared as the argument to the procedure. For example, the Comp procedure defined for the EMPLOYEE relation can be passed a STUDEMP tuple as in retrieve (SE.Name, 
Compensation = Comp@E)) 
from SE in STUDEMP because STUDEMP inherits data attributes from EMPLOYEE. The arguments to procedures that take relation tuples as arguments must be passed in a self-describing data structure because the procedure can be passed tuples from different relations. Attributes inherited from other relations may be in different positions in the relations . Moreover, the values passed for the same attribute name may be different types (e.g., the definition of an inherited attribute may be overridden with a different type). The self-describing data structure is a list of arguments , one per attribute in the tuple to be passed, with the following structure (A&Name, AttrType, A&Value) The procedure code will have to search the list to find the desired attribute. A library of routines is provided that will hide this structure from the programmer. The library will include routines to get the type and value of an attribute given the name of the attribute. For example, the following code fetches the value of the Birth&e attribute: GetValue( " Birthdote " J The problem of variable argument lists arises in all object-oriented programming languages and similar solutions are used. The model for procedure inheritance is nearly identical to method inheritance in object-oriented programming languages 
and its IPL is (STUDEMP, STUDENT, EMPLOYEE, PERSON) PERSON appears after EMPLOYEE rather than after STUDENT where it would appear in a depth-first search because both STUDENT and EMPLOYEE inherit attributes from PER- SON (see 
When a procedure is called and passed a tuple as the first argument, the actual procedure invoked is the first definition found with the same name when the procedures that take arguments from the relations in the ILP of the argument are searched in order. In the example above, the Comp procedure defined for STUDENT is called because there is no procedure named Comp defined for STUDEMP and STUDENT is the next relation in the IPL. The implementation of this procedure selection rule is relatively easy. Assume that two system catalogs are defined: PROCDEF(ProcName, ArgName, ProcId) IPL(RelationName, IPLEntry, SeqNo) where PROCDEF has an entry for each procedure defined and IPL maintains the precedence lists for all relations. The attributes in PROCDEF represent the procedure name, the argument type name, and the unique identifier for the procedure code stored in another catalog . The attributes in IPL represent the relation , an IPL entry for the relation, and the sequence number for that entry in the IPL of the relation. With these two catalogs, the query to find the correct procedure for the call Comp This query can be precomputed to speed up procedure selection. 
In summary, the major changes required to support procedure inheritance is 1) allow tuples as arguments to procedures, 2) define a representation for variable argument lists, and 31 implement a procedure selection mechanism. This extension to the relational model is relatively straightforward and only requires a small number of changes to the DBMS imple- mentation. 
Other Data Models
This section compares the POSTGRES data model to semantic, functional, and objectoriented data models. Semantic and functional data models 
