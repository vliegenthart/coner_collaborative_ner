introduction
The nested transaction concept was popularized by Moss 
Transaction and System Models
In this section, WC discuss the nested transact.ion model and the system architecture that we assume for ARIES/ NT. 
Nested Trcmsactions
The transaction model that ARIES/Nl' is designed for is a generalization of the nested transaction model of 
.riw) 
for the nonreflexive version of ancestor (descendant). The nesting hierarchy of a TL-transaction can be rcpresented by a so-called transaction tree, where the nodes of the tree represent transactions, and the edges represent the nesting relationship amongst the transactions. Transactions can t.erminate eitber normally by committing or abnormally by aborting. Subtransactions appear atomic to the surrounding transactions and may commit or abort independently. A transaction is not allowed to commit until all its children have terminatcd . A subtransaction may abort without afrecting the commit or abort outcome oft.he surrounding transacl .ion. IIowever, the commit of a subtransaction is relative; even if the subtransaction commits, aborting one of the subtransact.ion's superiors will undo its effects . Updates become permanent only when the enclosing TL-transaction commits. The concurrency control scheme for nested transacGon presented in [Moss811 is a locking approach. In this scheme, transactions may hold and retain locks. When a subtransaction commits, its locks are inherited by its parent, which then retains the locks. A t.ransaction holding a lock for an object is allowed to access this object. The access is not allowed if it only retains the lock. Consequently, a retained lock is only a place holder indicating that transactions outside the hierarchy of the retainer cannot acquire the lock, but descendants of the retainer can. The locking scheme introduced by Moss only allows for upward tien'tance of locks, i.e., a parent may inherit locks of its children, but not vice versa. In 
System Architecture
A distributed database system (DDBS) consists of a set of sites, which are interconnected via a commuttication network. Each site is comprised of a set of sulisystems, which cooperate with each other for the purpose of processing transactions. We assume that each subsystem has its own recovery component. On each site of the DDBS, there exists a special subsystem called the bookkeeper. Bookkeepers coordinate the initiation, migration and termination of transactions . Moreover, they maintain transaction s1at.e information , which is needed for recovery purposes, as well as information needed to build up transaction trees and to keep track of which transactions have visited which sites and which subsystems. The notations RK-subsystem and NBK-subsystem are used to denote a bookkeeper subsystem and a non-bookkeeper subsystem , respectively. An NBK-subsystem may be some component of a DDBS site, such as an index manager or a record manager. A transaction may be distributed over several NBKsubsystems , possibly residing on different sites of the DDBS. A transaction is initiated at a subsystem either when the subsystem receives the first request to be performed within this t.ransaction, or as soon as a child of this transaction commils at l.tiis sr~bsyslen~, whichever happens first. From an NDK-sllhsystcm's point of view, a sublransaction may bc in two diKcrcn1 states, namely " unknown " and " acl.ive " . AL a subsystem , the init.ial stale of a sublransactinn is " unknown " . The subtransaction enters the " active " state as soon as it gets initiated at the slJhsystem. It again becomes " unknown " when il commits or when one of its ancestors aborts. 'T'l.-transactions alone may also reside in the " prepared " sla1.e. This state can be reached during the execution of a 2-Phase-Commit (2PC) protocol (e.g., lhe Presumed Abort protocol of 
For each " active " snbtransaction, an NDK-subsystem will evenlually receive either a commit (for this snblransaction) or an abort (for an ancestor of this subtransacCon) request from the local I3K. A commit (respectively, ahart) request cbntains the identifier of lhc subtransaction to he committ.ed (aborted) as well as the identifier of the parent (inferiors, which arc " active " at this subsyst.em) of ~lis subtransaction. A commit. request will not be issued until all the children of (he committing snbtransaction have f.ermi- nated. For each " active " I'L-transaction, an NBKsubsystem will evenl.ually receive an abort or a prepare request rrom its local BK. While a prepare request contains lhe identifier of lhe 'H.-transaction to he prepared, an ahort request. includes Ihe identiliers of the 'II,-transaction's " active " descendants at tilis subsystem. A prepare request will no1 be issued until all the children of the preparing Tl.transaction have terminated. l 
 For each " prepared " '1'1:transaction, an NI<Ksubsystem will evcnluall\ receive a commit or an ahort rcquesl from ils local I3K. l 
For each " active " transnctic *a, an NBK-subsystem can issue a query lo the local HK asking for the transaction's inferiors residing in the " active " sta1.e at this subsys!.em. An NICK-subsystem needs this information when it decides lo unilat.erally abort a lransaclion. rorgct subtransactions alter commit and the analysis pass need not collect informalion about committed subtransactions, which simplifies recovery. 
When a transaction is aborted, the actions of that transaction and its (commit.ted or active) inferiors are rolled hack in reverse chronological order. I,ike ARIES, ARlES/JVI logs datahasc updates performed during rollback by mea~ls of CI.Rs. A Cl,R is also used to keep track how much or a transaction and its committed inferiors has already been rolled back and how nmch more remains to be undone. l'his is achieved by recording, in a CI.R, a set. or pointers, each of which points to the next log record to be processed in the BW-cllnin of the transaction or a committed inferior during undo. As in ARIES, in ARJES/NT also, restart proccssiug starts with an analysis pass, continues with a redo pass and ends with an undo pass. Redo processing of AJ<IES/NT works in exactly the same way as in ARIES, while the algorithms of the analysis and undo pass have been modified to support tree-structured log contents. 
Dntn Structzwes
In Ihis section, we describe some of the important data structures used by ARIES/NT at an NJJK-suhsysl.em. Each record in the log of an NRK-subsystem belongs to a so-called backward chain (RW-chain). A BWchain is associated with a transaction and connects the log records which arc relevant for undoing and redoing this transaction at a parlicular subsystem. and the current end-of-log address (RecLSN -rccovcry I SN), which is the address of the next log record 1.0 hc written. Whcncver a page is wrilten back to disk, IIIC corresponding entry is dclcted from DirtyPages. 
Normal Psocessing
The lbllowing two subsections describe thr algorilllms for database updates, transaction prcparc and commit. The third subsection presents the algorithm Ibr rollback , and Finally, the fourth subsection &scribes how checkpoints are taken during normal processing. 
Update
 When an NBK-subsystem receives the first work request of a transaction, the recovery manager (RM) of this subsystem checks whether the transaction is already " active " . The transaction would already be active , if a child of this transaction had executed at the subsystem and had committed before. If the transaction is still " unknown " , the RM inserts an ent.ry for the transaction in the RM's Transl'ah. 
. 
Whenever the execution of a work request causes a transaction to perform an update to an object. in a page, this page is fixed in the buffer and latched in the exclusive (X) mode, the update is applied, an Update log record is added to the transaction's BW-chain, the J,SN of the log record is placed in the page's LSN field, and the page is unlatched and unfixed (see 
Prepare and Commit
Suhtrancactionx When an NBK-subsystem receives a commit request for a subtransaction 'I' from its local OK, the RM of this subsystem checks whether there already exists an entry for T's parent in the local TransTab. If the entry does not exist, it changes the state of T's parent from " unknown " to " active " by inserting the corresponding entry in TransTab. Subsequently , it. asynchronol~rly writes a C-Committed (child commitl.ed) log record, which represent< the first record in the BW-chain of T's parent. On the ot.her hand, if T's parent is already " active " , it only adds a C- Committed record to the BW-chain of T's parent. The C-Committed record contains, hesides other information , t.he identifier of 'I' (Childld) as well as the log address of the last record in T's BW-Chain (1 ,astl,SN). A BW-chain that represents the root of a BWC-tree is called a root chain. An ancestor which represen1.s a root chain is denoted as a root ancestor. The BWchains of 'I'L-transactions as well as Ihe BW-chains of aborted or " active " sublransactions always rrprcscnt the root of a BWC-tree, whereas the BW-chains of committed subtransactions are always nonroot chains. Consequently, for each TL-transaction T, there might exist a forest of BWC-trees. which consists of T's BWC-tree and the BWC-trees of the " active " and aborted inferiors of 'I'. 
Rollback
When an NBK-subsystem receives an abort request for a transaction or it decides to unilaterally abort the transaction, it has to undo the effects ofthe transaction's " active " or " prepared " descendants (called knowndescendants ). We define the BWC-forest of a transaction to consist of the hWC-trees of the knowndescendants of this transaction. In order to rollback a transaction, the log records belonging to the transaction's BWC-forest have to be undone and compensated for. When rollback for a transaction starts, the rollback process only knows the root chains of the transaction's BWC-forest; however, as rollback proceeds, it learns about all the nonroot chains of this forest. In order to keep track of which BW-chains of a transaction are currently known, for each of the transaction's knowndescendants , a list calted KnownChains is maintained by the rollback process. The KnownChains list of a known-descendant contains an UndoNext pointer for each BW-chain (of the known-descendant's BWC-tree) which has so far been encountered by the rollback process. The UndoNext pointer of a BW-chain points to the next log record in the chain to be read and processed. When rollback of a transaction starts, the KnownChains tist of a known-descendant, say X, of this transaction contains one UndoNext pointer, which The CLRs compensating the log records belonging to a given BWC-tree are added to fhe root chain of this BWC-tree -i.e., CLRs can only occur in root chains (assuming there are no partial rollbacks -see 
c: D: E: F: ul I time I 
The rollback algorithm described above only allows for foral rollback of transactions. I Jowever, it has been extended to support parri& rollbacks also (see 
Checkpoints
For taking checkpoiuts periodically, the same fuzzy check~poirzfing mechanism as described in 
Restart Processing
When a system failure occurs, the secondary storage version of the database may be len in an inconsistent state. It may contain uncommitted updates. Moreover, it. may not contain some or all the updates of cornmilted (or aborted) transactions. In order lo reestablish a consistent database state, restart recovery has to be performed. Restart recovery is performed with three passes of the log, as outlined in the section " 3.1. Overview " . In the following, the three log passes are described in detail. 
Rsdo Nonlsnrs
3 -------- rs c'___--____ - -- ---.
.. . 
-.-.-.-.-.-.-.-.-.-.~~ 
P Rdo wml- 
.-.-.-.-.-.-.-.-.-.-.~, 
Analysis Pas
The analysis pass begins by reading the Master record. The TransTab and DirtyPages tables are initialized from the EndChpt record. The log is scanned forward starting with the BeginChpt record until the end of the log is reached. During this scan, depending on its type, a log record R written by a transaction X is processed as follows: l f&fate: If R represents the first log record in X's BW-chain, an entry is inserted into TransTab for X with State set to " active " and LastLSN set to R's LSN. Otherwise, in X's entry, LastLSN is set to R's LSN. If R.PageId is not in the DirtyPages table, a new entry is added lo this table. The entry consists of R.Pageid and R's LSN (as the RecLSN). l CLR: In X's Trans'l'ab entry, LastLSN is updated. If R.Pageld is not in the DirtyPages table, a new entry is added. l Prepare: In X's TtansTab entry, I.astLSN is updated and State is set to " prepared " . l C-Committed: The entry in TransTah for R.ChildJd is deleted. l End: X is forgotten by removing X's entry from TransTab. 
ARer the log is scanned until its end, RerJoLSN is set to the minimum of the RecLSN values in DirtyPages. This is the log address from which the redo pass will start processing the log. In summary, the output of the analysis pass is (1) the TransTab table, which contains the transactions that were in the " active " and " prepared " state at the time of the system failure, (2) the DirtyPages table, which contains the identifiers of the pages in the buffers that were potentially dirty when the system failure occurred, and (3) RedoLSN, which is the location on the log from which the redo pass should start processing tbc log. 
Redo Pass
The redo pass reestablishes the state of the database at the time of the system failure and reacquires locks for " prepared " transactions. The redo pass algorithm described for ARIES in 
Undo Pas
During the undo pass, the effects of all transactions residing in the " active " stab at the end of the analysis pass have to be undone. In the following, the set of BWC-trees of the these transactions are denoted by RestartUndo-Forest (R&Forest). The fate ofthe transactions in the " prepared " state will be determined after contact is reestablished with the commit coordinator (see 
In order to describe how the restart rollback process acts on the different types of log records, we assume that it selects UndoNext pointer P residing in the KnownChains list of transaction X. Further, WC assume that P points to log record R in IJW-chain (1. Depending on R's type the restart rollback process acts as follows: 
ARIES/NT is characterized by the following prnpcrtics: l It supports WAL, for nested transactions, and, as far as we know, it is the only comprehensive Whl, algorithm for nested transactions developed so far that permits semantically-rich modes of locking 
Moreover, all the properties of ARIES described in 
References
