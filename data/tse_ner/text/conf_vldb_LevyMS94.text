Introduction
Current benchmarks (e.g., TPC/D) have exposed a serious weakness of commercial database systems when it comes to query optimization. In some cases, several *Research supported iu part by Graut 4766-1-93 of the Israe& National Council for Remarch and Development. Permisrion to copy without fee all or port of thhir material ir granted provided that the copies are not made or dirtributcd for direct commercial advantage, the VLDB coppright notice and the title of the publication and itr date appear, and notice ir given that copqing ir bp permirrion of the Very Large Data Bare Endowment . To copp otherwire, or to republirh, reqrrirea a fee and/or special permirrion from the Endowment. Proceedings of the 20th VLDB Conference, 
Moving predicates up, down and sideways in the query graph, across query blocks that cannot be merged. 
 Moving predicates through aggregation; in the process , new predicates are deduced from aggregation. Using functional dependencies to deduce and move predicates. Moving EXISTS and NOT EXISTS predicates. The EXCEPT clause can also lead to a EOT EXISTS predicate that can then be moved. Removing redundant predicates. This is important, since redundant predicates can lead to incorrect selectivity estimates that may result in access paths and join methods that are far from optimal. Mor+ over, redundant predicates represent wasted compu- tation. 
 Our algorithm can be incorporated easily on top of existing query optimizers, since it consists of rewriting the original queries and views. For example, our algorithm would fit well in the Starburst optimizer 
Illustrative Example
We consider a detailed example that illustrates the benefits of the predicate move-around optimization. In particular, this example illustrates how predicates can be moved across query blocks, through aggregation and using knowledge about functional dependencies. This example is quite typical of the complexity of real world decision;aupport queries. Further, it illustrates the capabilities of our algorithm to deal with complex queries as compared to more traditional methods. The example uses the following base relations from a telephone database. calls(FromAC, FromTel, ToAC, ToTel, AccessCode, StartTime, Length) cuetoners(AC, Tel, OwnerName, Type, MemLevel) users(AC, Tel, UserName, AccessCode) secret(AC, Tel) pronotion(AC, SponsorName, StartingDate, EndingDate) 
The' calls relation has a tuple for every call made. A telephone number is represented by the area code (AC) and the local telephone number (Tel). Foreign numbers are given the area code " 011. " A call tuple contains the telephone number from which the call is placed, the number to which the call is placed, and the access code used to place the call (0 if an access code is not used). The starting time of the call, with a granularity of 1 minute, and the length of the call, again with 1 minute granularity, are included. Due to the time granularity and multiple lines having the same phone number, duplicates are permitted in thii relation. In particular, there can be several calls of 1 minute each starting within the same 1 minute, and there can be multiple calls running concurrently between two given numbers. The customers relation gives information about the owner of each telephone number. The information about owners consists of the owner's name, his account type (Government, Business, or Personal), and his membership level (Basic, Silver, or Gold). The key of the customers relation is (AC, Tel} and, so, the following functional dependency holds: {AC, Tel} -, {OwnerName, Type, MemLevel}. A telephone number can have one or more users that are listed in the users relation. Each user of a telephone number may have an access code. One user may have multiple access codes, and one access code may be given to multiple people. There are no duplicates in the U8ar8 relation. A few telephone numbers have been declared secret, as given by the secret relation. The promotion relation has, for each planned marketing promotion, the name of the sponsoring organization, the area codes to which calls are being promoted, and the starting and ending dates of the promotion. Note that there may be several tuples with the same area code and same sponsor, but with diierent dates. Example 2.1 Consider the query Ql given in 
The optimized views and query are denoted in 
(El): calls(FromAC, FromTel, ToAC, ToTel, AccessCode, StartTime, Length) customers(AC, Tel, OwnerName, Type, MemLevel) users(AC, Tel, UserName, AccessCode) secret(AC, Tel) promotion(AC, SponsorName, StartingDate, EndingDate) 
SQL syntax
An SQL query consists of a sequence of view definitions 
(or blocks). The following is a GROUPBY block. 
CREATEVIEW v(A1,...,A1)AS SELECT&,...,& FRonRe11 l-1, . ..) Rd, r, WHERE . . . GROUPBY G1,...,G, HAVIBG . . . for simplicity, we assume that the Xi's are distinct. If there are no GROUPBY and BAVIYG clauses, and no aggregate terms, then the above block is called a SELECT block; there are also UBION and IBTBRSECTIOH blocks. One of the blocks is the query block; it is similar to the above block, but without the CREATE-VIEW clause. In this paper, the search condition that appears in a WHERE or HAVING clause is assumed to be in the conjunctive normal form. Each conjunct in the search condition is called a predicate. We consider predicates that are built from comparisons (=, <, etc.), AND, OR, BOT, EXISTS, and BOT EXISTS. 
The Query Tree
The nodes of a query tree correspond to blocks (the root corresponds to the query block). The children of a node n are the views (i.e., non-base relations) referenced in the block corresponding to node n; e.g., a node for a SELECT block has a child for every occurrence of a view in the FROM clause. 
Local and Exported Attributes: 
 The local attributes of node n are those appearing in the operands of the corresponding block; the exported attributes axe 
(
Labels: 
In the query tree, each node n has an associated label, denoted L(n). The label contains predicates that are applicable to attributes of n. Due to functional dependencies, predicates appearing in labels may also contain functional terms; for example, if the attribute r.A functionally determines the attribute r.B, then the predicate f(r.A) = r.B is added to nodes having r.A and r.B as attributes. A predicate of a label L(n) is called local if all its attributes are local attributes of n; it is called cqotied if all its attributes are exported attributes of n. Next, we explain the four types of nodes in the query tree. SELECT rk, .BI , . . . , rk, . BI FROH RI& ri, . . . , 
GROUPBY Triplets and Nodes 
A view definition consisting of a GBOUPBY block is separated into three nodes (see The set of local attributes in ni (denoted by L) is defined in the same way as it is defined for an ordinary SELECT node, and is also the set of exported attributes of ni. Let G denote the set of grouping attributes (i.e., the attributes in the GROUPBY clause), and let A denote the set of aggregate terms (e.g., Maz(r.Q)) used in the SELECT and BAVIBG clauses. The attributes of the set L U A are the local attributes of n2, whereas G U A is the set of exported attributes of n2 and the set of local attributes of ng. The exported attributes of ns are {V.Al,. . .,V.At}. A view definition may have aggregation in the SELECT clause even without having GBOUPBY and HAVING clauses. In this case, we still construct a triplet (as if there is an empty GROUPBY clause). Also note that if there is no HAVING clause, then we can omit the top node and let V.Al, . . . , V.Al be the exported attributes of n2. DBIOP and IBTBBSECTIOB Nodes If a view definition includes UBIOB (or IBTBBSECTIOB), we create a node n for this operation (see 
DAG Queries 
In a DAG query, a view V may have several references in the same or different blocks. In this case, we create a distinct node for each occurrence of V. 
To move predicates around in the query tree, we utilize two kinds of renamings. An internal renaming for node n is a mapping from the local attributes of node n to the exported attributes of n or vice versa. Nodes created for SRLECT and GBOUPBY blocks have exactly one internal renaming in each direction. In the case of a UBIOB or an IPTBBBECTIOB node n, there is a pair of internal renamings (one in each direction) for each child c; this pair relates the exported attributes of n to the local attributes obtained from the child c. Internal renamings are used to infer exported predicates from predicates with local attributes and vice versa. An edernal renaming is simply a renaming from the exported attributes of a node n to local attributes referencing them in the parent of n. For example, the attribute fgACCOUnt8. AC is referenced as f g . AC in the root of ourexample query tree. External renamings are used in order to move predicates from a node to its parent and vice versa. Figure 5: The query tree for Example 2.1. The predicates in reman font are inserted during initialization. The predicates in bold font are added to the labels in the pullup phase. 
The Move-Around Algorithm
We give an overview of the main steps of the predicate move-around algorithm followed by a detailed description of each step. 2. Predicate pullup: The tree is traversed bottom up. At each node, we infer predicates on the exported attributes from predicates on the local attributes and pull up the inferred predicates into the parent node. 
The Main Steps of the
3. Predicate pushdown: The tree is traversed top down. At each node, we infer predicates on the local attributes from predicates on the exported attributes and push down the inferred predicates into the children of that node. 4. Label. minimization: A predicate can be removed from a node if it is already applied at a descendant of that node. The algorithm is extensible in the sense that it can be extended to new types of predicates (e.g., LIKE), to new types of nodes (e.g., outer join), and to new rules for inferring predicates. Next, we explain each step in detail. 
Label Initialization
SELECT Nodes: The initial label of a SELECT node consists of the predicates appearing in the WHERE clause. For example, in 
Predicate Pullup
 In the predicate-pullup phase, we traverse the tree bottom up, starting from the leaves. At each node, we infer predicates on the exported attributes from predicates on the local attributes. The inferred predicates are added to the labels of both the given node and its parent. The particular method for inferring additional predicates depends on the type of node under consideration and the types of predicates in the label of that node. 
Predicate pullup through SELECT nodes
To pull up predicates through a SELECT node n, having a label L(n), we proceed as follows. l Add to L(n) new predicates that are implied by those already in L(n). For example, if both r1.A < rp.B and r2.B < r3.C are in L(n), then r1.A < r3.C is added to L(n). Ideally, we would like to compute the closure of L(n) under logical implications, since that would maximize the effect of moving predicates around. However, the movearound algorithm remains correct even if we are not able to compute the full closure.2 l Infer predicates with exported attributes as follows. If (Y is in L(n), then add r(o) to L(n), where T is the internal renaming from the local attributes to the exported ones. For example, in the fgAccounts node of 
Predicate pullup through GBOUPBY nodes
In principle, it is enough to perform the three steps of the previous subsection at a GBOUPBY node. In practice, however, we need some rules for inferring predicates involving aggregate terms. Following is a (sound but not complete) set of such rules; these rules should be applied to the label, L(n), of a GBOUPBY node n (in all these rules, 5 can be replaced with <). 1. If Min(B) is a local attribute of n, then add Min(B) 5 B to L(n) (in words, the minimumvalue of B is less than or equal to every value in column B). Furthermore, if (B 2 c) E L(n), where c is a constant, then add Min(B) 2 c to L(n) (in words, if c is less than or equal to every value in column B, then c is also less than or equal to the minimum value of B). 
2. If Maz(B) is an attribute of n, then add Max(B) 1 B to L(n). Furthermore, if (B 5 c) E L(n), where c is a constant, then add Maz(B) 5 c to L(n). For example, consider the GBOGPBY node in 
MaxLen is an exported attribute that is an alias of Max(t.Length). For clarity, only MaxLen > 2 is shown in the 
Predicate pullup through UBIOP and IBTEBSECTIOll nodes
Consider a UBIOB (or IliTEBSECTIOI) node n, as shown in 
Predicate Pushdown This phase
of the algorithm is a generalization of predicate-pushdown techniques. The combination of pullup and pushdown effectively enables us to move predicates from one part of the tree to other parts. In this phase, we traverse the query tree top down, starting from the root. At each node, we infer new predicates on the local attributes from predicates on the exported attributes and push the inferred predicates down into the children nodes. As earlier, the pushdown process depends on the type of the node. 
Predicate pushdown through SELECT nodes
In a SELECT node n, with label L(n), we do as follows. 
Infer new predicates over the local attributes as follows. For each predicate (Y in L(n), add r(o) to L(n) (if it is not already there), where 7 is a renaming from the exported attributes of n to the local ones. Add to L(n) new predicates that are logically implied by those already in L(n). For each child c of n, if cy is a predicate in L(n) that includes only constants and renaming8 of attributes in c, then add g(o) to L(c), where d is the external renaming from the local attributes of n to the exported attributes of c. 
Example 4.3 In our example, we push the predicate ptc.MaxLen > 50 from the root into the GROUPBY node, where it is mapped onto the predicate MAX (t.Length) > 50 (see 
Predicate pushdown through GROUPBY nodes
The above three steps should also be performed at the GROUPBY nodes. However, we also need rules for inferring new predicates from predicates with aggregate terms. Following is a (sound but not complete) set of such rules; these rules should be applied to the label, L(n), of a GROUPBY node n (in all these rules, < can be replaced with <). Suppose that Maz(B) 2 c is in L(n), where c is a constant. In this case, we only need to look at tuples satisfying B 2 c in order to compute Ma%(B). However, if there are other aggregates to compute, we may also have to consider tuples that do not satisfy B 1 c. Therefore, if Maz(B) 1 c is in L(n), we add B > c to L(n) provided that Maz(B) is the on/y aggregate term in n. As an example, consider the GROUPBY node in 
When B 2 c cannot be inferred from Maz(B) 2 c, we can use Mm(B) 2 c directly in order to optimize the evaluation; however this extension is beyond the scope of this paper. 
Predicate pushdown through UlUO!i and IIiYERSECYIOl nodes
Consider a UIUOII (or IIYERSECTIOB) node n, as shown in 
Label Minimization
At the end of the topdown phase, new predicates appear in labels of nodes. As a result, we can apply predicates earlier than was possible in the original tree. There is the possibility, however, of applying predicates redundantly. In fact, even an evaluation of the original tree could result in redundant applications of predicates; this may happen, for example, when the original query is formulated using predefined views and the user is oblivious to the exact predicates that are used in those views (and, hence, he may redundantly repeat the same predicates in the query). In the move-around algorithm, redundancies are introduced in two ways. l As a result of renamings between attributes of nodes and the associated pullup (or pushdown), some predicate may appear in a'node and in the parent of that node (and, possibly, also in other ancestors of that node). There is no need, however, to apply a Figure 6: The query tree for Example 2.1 after the pushdown and minimization phases. The predicates in italic font are added during pushdown. Only predicates annotated with a star remain in labels after the minimization phase. 
predicate at a node if it has already been applied at a descendant of that node. l Redundancies are introduced at labels when adding predicates that are logically implied by existing ones. 
Removing redundancies is important for two reasons. First, it saves time, since fewer tests are applied during the evaluation of the query. Secondly, redundant predicates might mislead the plan optimizer due to incorrect selectivity estimates. Redundancies of the first kind are removed as follows. Suppose a is a local predicate of L(n) and that 6(7(o)) is the result of applying to a the internal renaming (to the exported attributes) followed by the *external renaming (to the attributes of n's parent). Then a predicate p in the parent of n is redundant if B is logically implied by 6(7(a)). After removing redundancies in this way, we should also discard all predicates that have some exported attributes. Redundancies of the second kind are removed by the known technique of transitive reduction; we repeatedly remove a predicate from a label if it is implied by the rest of the predicates. We get a nonredundant label when no more predicates can be removed. Finally, we can completely remove labels of UIiIOl, IREllSBCTIOI and GROUPBY nodes. Moreover, predicates containing functional terms (that were generated from functional dependencies and aggregations) are also dropped from all nodes. In 
Translating the Query Tree to SQL
The query tree may be used directly for further rewrite and cost-based optimizations as well as evaluation of the query. In fact, the query tree is similar to the internal representations of queries used by some existing query processors. If desired, however, we can easily translate the query tree back into SQL as follows. SELECT, UNION and IRTERSECTIOH nodes, and GBOUPBY triplets are translated into the appropriate SQL statements; the UBBBB and HAVIMG clauses consist of the minimal labels of the corresponding nodes. In our example, the optimized SQL query and views of 
Translating
DAG Queries When a query tree is created from a DAG query, several subtrees of the tree may correspond to the same view. These subtrees are identical at the beginning of the move-around algorithm, but may become different at the end of the algorithm. Consider two subtreea, 2'1 and T2, generated from the same view V. If, at the end of the algorithm, Tl and Ta are equivalent (i.e., they have logically equivalent labels in corresponding nodes), then it is sufficient to evaluate just one of Tl and T2. If Tl is contained in Ta, then the view for Ta may be computed from the view for Tl by applying an additional selection. If neither one is contained in the other, it may still be possible to compute one view from which the two views can be obtained by additional selections. 
Correctness of the Algorithm
Theorem 4.1 Let Q be a query and Q' be the rewritten query produced by the predicate moue-around algorithm. The queries Q and Q' are equivalent, i.e., they produce the same answer for all databases. 0 Proof: (Sketch:) The proof proceeds by induction on the steps of the algorithm. Let bu(n) and td(n) denote the labels of node n at the end of the pullup and pushdown phases, respectively. A bottom-up induction on the nodes in the query tree shows that any tuple computed at node n must satisfy bu(n). A top-down induction on the nodes of the query tree shows that in order to compute at node n all the tuplea that satisfy M(n), it suffices to consider at the children nl , . . . , n, of n only those tuples that satisfy td(nl), . . . , td(n,), respectively. Finally, we show that the label-minimization phaze removes only redundant predicates, i.e., predicates that are guaranteed to be applied at lower nodes during the evaluation of the query. 0 For queries without aggregation, our algorithm pro duces an optimal query in the following sense. Any attempt to add a predicate to the label of some node either would not change the set of tuples generated at that node or, for some databases, a wrong result would be computed by the query tree. Consequently, predicates are applied as early as possible in the evaluation in the resulting query. ing the join order and, moreover, can move predicates in all directions, without creating an additional overhead of auxiliary predicates. Furthermore, doing predicate move-around improves the ability to determine the op timal join order. The magic-set transformation can be applied after predicate movearound in order to move join predicates in the direction of the join order. There has been a lot of work on optimising subqueries and eliminating correlations 
Conclusions
We have described a very general technique for moving predicates around in a query, thus determining the earliest point when predicates can be applied. Our method can handle hierarchical and dag queries. The predicates moved around include arithmetic comparisons, negative predicates (IOT EXISTS and EXCEPT), functional dependencies and aggregation constraints. Furthermore, we can also handle the LIISE predicate of SQL [IS0931 (in a fashion similar to equality) and arithmetic constraints (e.g., X = Y + 2). When moving predicates, we can also consider the constraints that hold in database relations . For example, if it is known that the range of an attribute A of a relation R is between 0 and 10, we insert the predicates r.A 2 0 and r.A 5 10 in the label of any node that refers to R. In many cases, the result of the predicate movearound algorithm is optimal (in the sense that predicates are moved to all parts of the query in which they are applicable). In particular, optima&y is guaranteed for queries without aggregation. Achieving an optimal result for queries involving aggregation requires a better understanding of techniques for reasoning about aggregation constraints, which is a subject of current re search. The work of [SRSSS$ is a first step in that direction. The query-tree technique is a general algorithm and is easily extensible to new kinds of predicates and operators, including recursive SQL queries. Predicate move-around is a generalization of predicate pushdown techniques. When predicate move around detects optimizations that cannot be found by ordinary pushdown techniques, the additional savings may be arbitrarily large, depending upon the selectivity of the predicates being moved. Furthermore, such pavings are very likely to be diivered in complex queries, such as those encountered in decision-support applications . A significant aspect of the improved performance of predicate move-around is the ability to deal with aggregation operators, which are a major cause. for poor performance of current optimisers. The move-around algorithm is easy to implement and can simply replace an existing pushdown module in a query optimizer. 
